#!/bin/bash
#
# Short:    Trigger an event
# Author:   Mark J Swift
# Version:  2.0.17
# Modified: 05-Oct-2017
#
# Called as follows:    
#   Trigger <event> <LoggedInUser> [<optionalparam>]
#
# Handles the following system events:
#   Sys-Boot                         (as root)
#   Sys-LoginWindow                  (as root)
#   Sys-NetworkUp                    (as root)
#   Sys-NetworkDown                  (as root)
#   Sys-LoginWindowPoll              (as root)
#   Sys-LoginWindowIdle              (as root)
#   Sys-Poll                         (as root)
#   Sys-Idle                         (as root)
#   Sys-ActiveDirectoryUp            (as root)
#   Sys-ActiveDirectoryDown          (as root)
#   Sys-ConsoleUserLoggedIn          (as root)
#   Sys-ConsoleUserLoggedOut         (as root)
#   Sys-ConsoleUserSwitch            (as root)
#   Usr-AtDesktop                    (as user)
#   App-WillLaunch                   (as user)
#   App-DidLaunch                    (as user)
#   App-DidTerminate                 (as user)
#   Usr-Poll                         (as user)
#   Usr-Idle                         (as user)
#
# And if loginhooks are active...
#   Sys-Login                        (as root)
#   Sys-Logout                       (as root)
#   Usr-Login                        (as user)
#   Usr-Logout                       (as user)

# ---

# Get policy
sv_EventName="${1}"

if test -z "${sv_EventName}"
then
  # We need something to work with
  exit 0
fi

# Get logged in user
GLB_sv_LoggedInUserName="${2}"

# Get optional parameter
sv_OptionalParam="${3}"

# ---
# The event history is the sequence of events that led to this event
# Usually the history is blank, unless a policy deliberately triggers an event

sv_EventHistory=""
if test -n "$(echo ${sv_EventName} | grep ':')"
then
  # If there is a history of events, separate event name from event history
  sv_EventHistory=$(echo "${sv_EventName}" | sed "s|:[^:]*$||")
  sv_EventName=$(echo ${sv_EventHistory} | sed "s|.*:||")
fi

# ---
# Check if a target policy has been passed in the event name
# (i.e. /usr/local/LabWarden/lib/Trigger "Sys-AddPrinter.Sys-Poll")

sv_TargetPolicyName=""
if test -n "$(echo ${sv_EventName} | grep -E '\.')"
then
  # If there is a target policy, separate event name from target policy
  sv_TargetPolicyName=$(echo "${sv_EventName}" | sed "s|\..*$||")
  sv_EventName=$(echo ${sv_EventName} | sed "s|.*\.||")
fi

# ---

# Check event history and quit if the event has already been handled - prevents trigger loops
if test -n "$(echo ${sv_EventHistory} | tr ":" "\n" | sed "s|.*\.||" | grep -E "^"${sv_EventName}"$")"
then
  exit 0
fi
      
# ---

# Load the library, only if it is not already loaded
if test -z "${GLB_sv_ProjectSignature}"
then
  . /usr/local/LabWarden/inc/Common.sh
fi

# ---

# List policies in config that are triggered by the event
GLB_nf_TriggeredList() # <ConfigPlist> <EventName>
{
  local sv_ConfigPlist
  local sv_EventName
  local iv_DoesTriggerCount
  local iv_DoesTriggerIndex
  local sv_ConfigEntryName
    
  sv_ConfigPlist="${1}"
  sv_EventName="${2}"
  iv_DoesTriggerCount="$(GLB_if_GetPlistArraySize "${sv_ConfigPlist}" ":${sv_EventName}:DoesTrigger")"
  for (( iv_DoesTriggerIndex=0; iv_DoesTriggerIndex<${iv_DoesTriggerCount}; iv_DoesTriggerIndex++ ))
  do
    sv_ConfigEntryName=$(GLB_sf_GetPlistProperty "${sv_ConfigPlist}" ":${sv_EventName}:DoesTrigger:${iv_DoesTriggerIndex}")
    echo ${sv_ConfigEntryName}
  done
}
  
# ---

if test -z "${sv_TargetPolicyName}"
then
  GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Event '${sv_EventName}' triggered"
else
  GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Targeted event '${sv_TargetPolicyName}.${sv_EventName}' triggered"
fi

# ---

# Do a bit of housekeeping during certain events

case "${sv_EventName}" in
Sys-Boot)
  # Make sure the login hooks are set up (but only if required)
  sv_CurrentLoginHookFilePath="$(defaults read com.apple.loginwindow LoginHook)"
  sv_CurrentLogoutHookFilePath="$(defaults read com.apple.loginwindow LogoutHook)"

  if [ "${GLB_bv_UseLoginhookDefault}" = "true" ]
  then
    # Add LoginHook
    if test -z "${sv_CurrentLoginHookFilePath}"
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Installing LoginHook ${sv_CurrentLoginHookFilePath}"
      defaults write /private/var/root/Library/Preferences/com.apple.loginwindow LoginHook "/usr/local/${GLB_sv_ProjectName}/lib/LoginHook"
    else
      if test -z "$(echo "${sv_CurrentLoginHookFilePath}" | grep "^/usr/local/${GLB_sv_ProjectName}")"
      then
        GLB_nf_logmessage ${GLB_iv_MsgLevelErr} "LoginHook in use ${sv_CurrentLoginHookFilePath}"
      fi
    fi
  
    # Add LogoutHook
    if test -z "${sv_CurrentLogoutHookFilePath}"
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Installing LogoutHook ${sv_CurrentLoginHookFilePath}"
      defaults write /private/var/root/Library/Preferences/com.apple.loginwindow LogoutHook "/usr/local/${GLB_sv_ProjectName}/lib/LogoutHook"
    else
      if test -z "$(echo "${sv_CurrentLogoutHookFilePath}" | grep "^/usr/local/${GLB_sv_ProjectName}")"
      then
        GLB_nf_logmessage ${GLB_iv_MsgLevelErr} "LogoutHook in use ${sv_CurrentLogoutHookFilePath}"
      fi
    fi

  else
    # Remove LoginHook
    if test -n "$(echo "${sv_CurrentLoginHookFilePath}" | grep "^/usr/local/${GLB_sv_ProjectName}")"
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Removing LoginHook ${sv_CurrentLoginHookFilePath}"
      defaults write com.apple.loginwindow LoginHook ""
    fi
  
    # Remove LogoutHook
    if test -n "$(echo "${sv_CurrentLogoutHookFilePath}" | grep "^/usr/local/${GLB_sv_ProjectName}")"
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Removing LogoutHook ${sv_CurrentLogoutHookFilePath}"
      defaults write com.apple.loginwindow LogoutHook ""
    fi
  fi
  ;;

Sys-ActiveDirectoryUp)
  if [ "${GLB_sv_ThisUserName}" = "root" ]
  then
    # Update/apply workstation policies (but if already cached, does very little)
    /usr/local/${GLB_sv_ProjectName}/util/gpupdate "-quick"
  fi
  ;;
    
Sys-ConsoleUserLoggedIn|Usr-AtDesktop)
  if test -n "${GLB_sv_LoggedInUserName}"
  then
    # Update/apply user policies (but if already cached, does very little)
    /usr/local/${GLB_sv_ProjectName}/util/gpupdate "-quick" "${GLB_sv_LoggedInUserName}"
  fi
  ;;
  
Sys-Poll)
  if [ "${GLB_sv_ThisUserName}" = "root" ]
  then
    # Update/apply workstation policies (as root) (if deemed to old)
    /usr/local/${GLB_sv_ProjectName}/util/gpupdate
  fi
  ;;
    
Usr-Poll)
  if test -n "${GLB_sv_LoggedInUserName}"
  then
    # Update/apply user policies (as user) (if deemed to old)
    /usr/local/${GLB_sv_ProjectName}/util/gpupdate "${GLB_sv_LoggedInUserName}"
  fi
  ;;

esac

# ---

# Check policies against event

bv_EventHasPolicies="false"
  
if test -n "${GLB_sv_LoggedInUserName}"
then
  # Run through the user policies
  sv_ConfigDirPath="${GLB_sv_ProjectConfigDirPath}/Config/Users/${GLB_sv_LoggedInUserName}"
  while read sv_ConfigEntryName
  do
    if test -n "${sv_ConfigEntryName}"
    then
      sv_ConfigFilePath="${sv_ConfigDirPath}/${sv_ConfigEntryName}.plist"
      sv_PolicyFilePath=$(GLB_sf_PolicyFilePath "${sv_ConfigFilePath}" "${sv_ConfigEntryName}")
      if test -n "${sv_PolicyFilePath}"
      then
        # Run script in background
        if test -z "${sv_TargetPolicyName}"
        then
          # Event isn't targeted
          GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Executing: '${sv_PolicyFilePath}' '${sv_ConfigFilePath}' '${sv_ConfigEntryName}' '${sv_EventHistory}:${sv_EventName}' '${GLB_sv_LoggedInUserName}' '${sv_OptionalParam}'"
        "${sv_PolicyFilePath}" "${sv_ConfigFilePath}" "${sv_ConfigEntryName}" "${sv_EventHistory}:${sv_EventName}" "${GLB_sv_LoggedInUserName}" "${sv_OptionalParam}" &
          bv_EventHasPolicies="true"
        else
          # Event is targeted
          sv_PolicyName=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Name")
          if [ "${sv_PolicyName}" = "${sv_TargetPolicyName}" ]
          then
            GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Executing: '${sv_PolicyFilePath}' '${sv_ConfigFilePath}' '${sv_ConfigEntryName}' '${sv_EventHistory}:${sv_EventName}' '${GLB_sv_LoggedInUserName}' '${sv_OptionalParam}'"
        "${sv_PolicyFilePath}" "${sv_ConfigFilePath}" "${sv_ConfigEntryName}" "${sv_EventHistory}:${sv_EventName}" "${GLB_sv_LoggedInUserName}" "${sv_OptionalParam}" &
            bv_EventHasPolicies="true"
          fi
        fi
      fi
    fi
  done < <(GLB_nf_TriggeredList "${sv_ConfigDirPath}/${GLB_sv_ProjectName}-Events.plist" "${sv_EventName}" | sort -u)
fi
  
# Run through the workstation policies
sv_ConfigDirPath="${GLB_sv_ProjectConfigDirPath}/Config/Computers/${GLB_sv_Hostname}"
while read sv_ConfigEntryName
do
  if test -n "${sv_ConfigEntryName}"
  then
    sv_ConfigFilePath="${sv_ConfigDirPath}/${sv_ConfigEntryName}.plist"
    sv_PolicyFilePath=$(GLB_sf_PolicyFilePath "${sv_ConfigFilePath}" "${sv_ConfigEntryName}")
    if test -n "${sv_PolicyFilePath}"
    then
      # Run script in background
      if test -z "${sv_TargetPolicyName}"
      then
        # Event isn't targeted
        GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Executing: '${sv_PolicyFilePath}' '${sv_ConfigFilePath}' '${sv_ConfigEntryName}' '${sv_EventHistory}:${sv_EventName}' '${GLB_sv_LoggedInUserName}' '${sv_OptionalParam}'"
        "${sv_PolicyFilePath}" "${sv_ConfigFilePath}" "${sv_ConfigEntryName}" "${sv_EventHistory}:${sv_EventName}" "${GLB_sv_LoggedInUserName}" "${sv_OptionalParam}" &
        bv_EventHasPolicies="true"
      else
        # Event is targeted
        sv_PolicyName=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Name")
        if [ "${sv_PolicyName}" = "${sv_TargetPolicyName}" ]
        then
          GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Executing: '${sv_PolicyFilePath}' '${sv_ConfigFilePath}' '${sv_ConfigEntryName}' '${sv_EventHistory}:${sv_EventName}' '${GLB_sv_LoggedInUserName}' '${sv_OptionalParam}'"
          "${sv_PolicyFilePath}" "${sv_ConfigFilePath}" "${sv_ConfigEntryName}" "${sv_EventHistory}:${sv_EventName}" "${GLB_sv_LoggedInUserName}" "${sv_OptionalParam}" &
          bv_EventHasPolicies="true"
        fi
      fi
    fi
  fi
done < <(GLB_nf_TriggeredList "${sv_ConfigDirPath}/${GLB_sv_ProjectName}-Events.plist" "${sv_EventName}" | sort -u)
  
if [ "${bv_EventHasPolicies}" = "false" ]
then
  GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Event ignored, '${sv_EventName}' (no associated policy)"
fi

# We dont want to continue until all sub tasks are finished
while [ -n "$(jobs -r)" ]
do
  # We don't want to hog the CPU - so lets sleep a while
  GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Waiting for policies triggered by '${sv_EventHistory}:${sv_EventName}' to finish"
  sleep 1
done

# If we are root we will always be root
while [ "${GLB_sv_ThisUserName}" = "root" ]
do
  # Create a list of 'Trigger' process PIDs
  ps -U root -xo "pid, user, command" | grep "${GLB_sv_ThisScriptFilePath}" | grep -v "grep" | sed "s|^[ ]*||;s| .*||" | sort -u > "${GLB_sv_ThisScriptTempDirPath}/PID.txt"

  # Get the PID of the 'Trigger' process with the highest PID
  iv_HighestTriggerPID=$(cat "${GLB_sv_ThisScriptTempDirPath}/PID.txt" | tail -n1)
  if [ ${GLB_iv_ThisScriptPID} != ${iv_HighestTriggerPID} ]
  then
    # All other 'Trigger' processes just quit
    break
  fi

  # The 'Trigger' process with the highest PID processes all Shutdown and Restart requests
  iv_TriggerCount=$(cat "${GLB_sv_ThisScriptTempDirPath}/PID.txt" | wc -l | sed "s|^[ ]*||;s|[ ]*$||")
  if [ ${iv_TriggerCount} -eq 1 ]
  then
    # We only Shutdown or Restart when this is the only 'Trigger' process running

    if [ "$(GLB_nf_TestNamedFlag Restart)" = "true" ]
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Restarting workstation"
      shutdown -r now
    fi
  
    if [ "$(GLB_nf_TestNamedFlag Shutdown)" = "true" ]
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Shutting down workstation"
      shutdown -h now
    fi
    
    break
  fi

done

# ---

if test -z "${sv_TargetPolicyName}"
then
  GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Event '${sv_EventName}' complete"
else
  GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Targeted event '${sv_TargetPolicyName}.${sv_EventName}' complete"
fi

# ---

# Remove temporary files
rm -fPR "${GLB_sv_ThisScriptTempDirPath}"
