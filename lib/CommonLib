#!/bin/bash
#
# Short:    Common library used by almost all the LabWarden scripts
# Author:   Mark J Swift
# Version:  1.0.97
# Modified: 19-Sep-2016
#
# 'CommonLib' should be included into scripts as follows:
#   . /usr/local/LabWarden/lib/CommonLib
#
# Take a look at the example policy scripts before getting bogged down with detail.
#  (AppExamplePolicy, SystemExamplePolicy and UserExamplePolicy)
#
# Enter 'CommonLib' with the following globals already defined
#  LW_sv_LoggedInUserName                - The name of the logged-in user, a null string signifies no-one is logged in
#                                        - The logged-in user may or may not be the user who is running the script
#
# 'CommonLib' calculates the following LabWarden globals:
#
#  LW_sv_LabWardenVersion                - Main code version
#  LW_sv_LabWardenSignature              - LabWarden signature (com.github.execriez.LabWarden)
#
#  LW_iv_LogMaxLength                    - Maximum length of LabWarden log(s)
#  LW_bv_LogIsActiveDefault              - Whether we should log by default (true/false)
#  LW_bv_LogIsActiveStatus               - Whether the log is currently active (true/false)
#
#  LW_sv_BinDirPath                      - Path to binaries such as rsync or CocoaDialog
#  LW_sv_SettingsDirPath                 - Path to main LabWarden settings files
#
#  LW_iv_ThisScriptStartEpoch            - When the script started running
#  LW_sv_ThisScriptFilePath              - Full source path of running script
#  LW_sv_ThisScriptDirPath               - Directory location of running script
#  LW_sv_ThisScriptFileName              - filename of running script
#  LW_sv_ThisScriptName                  - Filename without extension
#  LW_iv_ThisScriptPID                   - Process ID of running script
#
#  LW_sv_ThisScriptTempDirPath           - Temporary Directory for the currently running script
#
#  LW_sv_ThisUserTempDirPath             - Temporary Directory for the current user
#  LW_sv_ThisUserLogDirPath              - Directory where the user log is stored
#  LW_sv_ThisUserPrefDirPath             - Directory for user configs
#
#  LW_sv_ThisUserName                    - The name of the user that is running this script
#  LW_iv_ThisUserID                      - The user ID of the user that is running this script
#
#  LW_iv_LoggedInUserID                  - The user ID of the logged-in user
#  LW_bv_LoggedInUserIsAdmin             - Whether the logged-in user is an admin (true/false)
#  LW_bv_LoggedInUserIsLocal             - Whether the logged-in user account is local (true/false)
#  LW_bv_LoggedInUserIsMobile            - Whether the logged-in user account is mobile (true/false)
#
#  LW_sv_LoggedInUserHomeDirPath         - Home directory for the logged-in user
#  LW_sv_LoggedInUserLocalHomeDirPath    - Local home directory for the logged-in user (in /Users)
#  LW_sv_LoggedInUserHomeNetworkDirPath  - Network home directory path, i.e. /Volumes/staff/t/testuser
#  LW_sv_LoggedInUserHomeNetworkURI      - Network home directory URI, i.e smb://yourserver.com/staff/t/testuser
#  LW_bv_LoggedInUserHomeIsLocal         - Whether the logged-in user account is local (true/false)
#
#                                        - The logged-in user may or may not be the user who is running the script
#
#  LW_iv_BuildVersionStampAsNumber       - The build version represented as a number, i.e. 14F1808 translates to 29745664
#  LW_sv_BuildVersionStampAsString       - The build version represented as a string, i.e. 14F1808
#  LW_iv_SystemVersionStampAsNumber      - The system version represented as a number, i.e. 10.10.5 translates to 168428800
#  LW_sv_SystemVersionStampAsString      - The system version represented as a string, i.e. 10.10.5
#
#  LW_sv_IPv4PrimaryService              - A uuid like 9804EAB2-718C-42A7-891D-79B73F91CA4B
#  LW_sv_NetworkServiceDHCPOption15      - The domain advertised by DHCP
#  LW_sv_NetworkServiceInterfaceName     - i.e. Wi-Fi
#  LW_sv_NetworkServiceInterfaceDevice   - i.e. en1
#  LW_sv_NetworkServiceInterfaceHardware - i.e. Airport
#
#  LW_sv_ADTrustAccount                  - This is the account used by the workstation for AD services - i.e. workstationname$
#  LW_sv_ADComputerName                  - i.e. workstationname
#  LW_sv_ADDomainNameFlat                - i.e. yourdomain.yourcompany.com
#  LW_sv_ADDomainNameDNS                 - i.e. YOURDOMAIN
# And when LW_sv_ThisUserName=root, the following global is defined
#  LW_sv_ADTrustPassword                 - This is the password used by the workstation for AD services
#
# 'CommonLib' defines the following LabWarden functions:
#
#  LW_if_SystemIdleSecs
#  LW_sf_urlencode <string>                                        - URL encode a string
#  LW_sf_urldecode <string>                                        - URL decode a string
#  LW_nf_logmessage <messagetxt>                                   - Output message text to the log file
#  LW_nf_ShowNotification <Title> <Text>                           - Show a notification dialog
#  LW_nf_SetPlistProperty <plistfile> <property> <value>           - Set a property to a value in a plist file
#  LW_sf_GetPlistProperty <plistfile> <property> [defaultvalue]    - Get a property value from a plist file
#  LW_if_GetPlistArraySize <plistfile> <property>                  - Get an array property size from a plist file
#  LW_nf_schedule4epoch <TAG> <WAKETYPE> <EPOCH>                   - Schedule a wake or power on for a given epoch
#  LW_sf_ResolveFilename <fileuri>                                 - Resolve a file URI to a local path (downloading the file if necessary)
#  LW_nf_QuickExit                                                 - Quickly exit a script
#  LW_nf_TriggerEvent <eventHistory> <event> [OptionalParam]       - Internal private function
#
#  Key:
#    LW_ - LabWarden global variable
#
#    bv_ - string variable with the values "true" or "false"
#    iv_ - integer variable
#    sv_ - string variable
#
#    nf_ - null function    (doesn't return a value)
#    bf_ - boolean function (returns string values "true" or "false"
#    if_ - integer function (returns an integer value)
#    sf_ - string function  (returns a string value)

# ---

LW_sv_LabWardenSignature="com.github.execriez.LabWarden"

LW_sv_LabWardenVersion="1.0.96"

# ---

LW_iv_LogMaxLength=250000

# ---

LW_bv_LogIsActiveDefault="true"
LW_bv_LogIsActiveStatus=${LW_bv_LogIsActiveDefault}

# ---

# Take a note when this script started running
LW_iv_ThisScriptStartEpoch=$(date -u "+%s")

# -- Begin Function Definition --

# Get seconds that mac mouse/keyboard is idle - thanks to https://github.com/CLCMacTeam/IdleLogout
LW_if_SystemIdleSecs()
{
  echo $(($(ioreg -c IOHIDSystem | sed -e '/HIDIdleTime/ !{ d' -e 't' -e '}' -e 's/.* = //g' -e 'q') / 1000000000))
}

# urlencode/urldecode functions - thanks to https://gist.github.com/cdown/1163649
LW_sf_urlencode() {
    # urlencode <string>

    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%s' "$c" | xxd -p -c1 |
                   while read c; do printf '%%%s' "$c"; done ;;
        esac
    done
}

LW_sf_urldecode() {
    # urldecode <string>

    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

# Save a message to the log file
LW_nf_logmessage()   # messagetxt
{  
  local iv_HalfLen
  
  # Check if we need to trim the log
  touch "${LW_sv_ThisUserLogDirPath}/LabWarden.log"
  if [ $(stat -f "%z" "${LW_sv_ThisUserLogDirPath}/LabWarden.log") -gt ${LW_iv_LogMaxLength} ]
  then
    iv_HalfLen=$(($(cat "${LW_sv_ThisUserLogDirPath}/LabWarden.log" | wc -l)/2))
    cat "${LW_sv_ThisUserLogDirPath}/LabWarden.log" | tail -n ${iv_HalfLen} > "${LW_sv_ThisUserTempDirPath}/LabWarden.log.$$"
    mv -f "${LW_sv_ThisUserTempDirPath}/LabWarden.log.$$" "${LW_sv_ThisUserLogDirPath}/LabWarden.log"
  fi

  if [ "${LW_bv_LogIsActiveStatus}" = "true" ]
  then
    echo "$(date '+%d %b %Y %H:%M:%S') ${LW_sv_ThisScriptFileName}[${LW_iv_ThisScriptPID}]: ${1}"  >> "${LW_sv_ThisUserLogDirPath}/LabWarden.log"
    echo >&2 "$(date '+%d %b %Y %H:%M:%S') ${LW_sv_ThisScriptFileName}[${LW_iv_ThisScriptPID}]: ${1}"
  fi
}

LW_nf_RestartNow()
{
  LW_nf_logmessage "${1}"
  touch "${LW_sv_ThisUserTempDirPath}/RestartNow"
}

LW_nf_ShutdownNow()
{
  LW_nf_logmessage "${1}"
  touch "${LW_sv_ThisUserTempDirPath}/ShutdownNow"
}

LW_nf_QuickExit()   # Quickly exit the script 
{
  if test -n "${1}"
  then
    LW_nf_logmessage "${1}"
  fi
  
  # Remove temporary files
  rm -fPR "${LW_sv_ThisScriptTempDirPath}"
  
  exit 99
}

# Show a pop-up notification
LW_nf_ShowNotification() # Title Text
{
  local sv_Title
  local sv_Text
  local sv_CocoaDialogFilePath
  local sv_Result

  sv_Title="${1}"
  sv_Text="${2}"

  sv_CocoaDialogFilePath="${LW_sv_BinDirPath}/CocoaDialog.app/Contents/MacOS/CocoaDialog"
  if test -f "${sv_CocoaDialogFilePath}"
  then
    sv_Result=$("${sv_CocoaDialogFilePath}" bubble \
    --timeout "15" \
    --x-placement "center" \
    --y-placement "center" \
    --title "${sv_Title}" \
    --text "${sv_Text}" \
    --border-color "808000" \
    --background-bottom "cfcf4f" \
    --background-top "ffffcf" \
    --debug \
    --icon "hazard")
  fi
}

LW_if_GetPlistArraySize()   # plistfile property - given an array property name, returns the size of the array 
{
  local sv_PlistFilePath
  local sv_PropertyName

  sv_PlistFilePath="${1}"
  sv_PropertyName="${2}"

  /usr/libexec/PlistBuddy 2>/dev/null -c "Print ':${sv_PropertyName}'" "${sv_PlistFilePath}" | grep -E "^ " | grep -E "$(/usr/libexec/PlistBuddy 2>/dev/null -c "Print ':${sv_PropertyName}'" "${sv_PlistFilePath}" | grep -E "^ " | head -n1 | sed "s|\(^[ ]*\)\([^ ]*.*\)|\^\1\\[\^ }\]|")" | wc -l | sed "s|^[ ]*||"
}

# Set a property value in a plist file
LW_nf_SetPlistProperty()   # plistfile property value
{
  local sv_PlistFilePath
  local sv_PropertyName
  local sv_EntryValue
  local sv_EntryType
  local sv_ThisEntryIndex
  local sv_ThisEntryPath
  local sv_ThisEntryType
  local iv_EntryDepth
  local iv_LoopCount
  local iv_Nexti
  local sv_NextEntry

  sv_PlistFilePath="${1}"
  sv_PropertyName="${2}"
  
  # We need to escape the escape character if we want to store it as expected
  sv_EntryValue="$(echo "${3}" | sed 's|\\|\\\\\\|g')"

  # Discover Entry Value Type
  if test -n "$(echo ${sv_EntryValue} | grep -E '[^0-9]')"
  then
    if test -n "$(echo ${sv_EntryValue} | grep -iE '^True$|^False$')"
    then
      # value is a bool
      sv_EntryType="bool"
    else
      # value is a string
      sv_EntryType="string"
    fi
  else
    if test -n "${sv_EntryValue}"
    then
      # value is a integer
      sv_EntryType="integer"
    else
      # value is a string (null)
      sv_EntryType="string"
    fi
  fi

  # Create Entry path
  sv_ThisEntryPath=""
  iv_EntryDepth="$(echo "${sv_PropertyName}" | tr ":" "\n" | wc -l | sed "s|^[ ]*||")"
  for (( iv_LoopCount=2; iv_LoopCount<=${iv_EntryDepth}; iv_LoopCount++ ))
  do
    sv_ThisEntryIndex="$(echo "${sv_PropertyName}" | cut -d":" -f${iv_LoopCount} )"
    sv_ThisEntryPath="${sv_ThisEntryPath}:${sv_ThisEntryIndex}"
    if [ ${iv_LoopCount} -eq ${iv_EntryDepth} ]
    then
      sv_ThisEntryType=${sv_EntryType}
    else
      iv_Nexti=$((${iv_LoopCount}+1))
      sv_NextEntry="$(echo "${sv_PropertyName}" | cut -d":" -f${iv_Nexti} )"
      if test -n "$(echo ${sv_NextEntry} | grep -E '[^0-9]')"
      then
        sv_ThisEntryType="dict"  
      else
        sv_ThisEntryType="array" 
      fi
    fi
    /usr/libexec/PlistBuddy >/dev/null 2>&1 -c "Print '${sv_ThisEntryPath}'" "${sv_PlistFilePath}"
    if [ $? -ne 0 ]
    then
      /usr/libexec/PlistBuddy >/dev/null 2>&1 -c "Add '${sv_ThisEntryPath}' ${sv_ThisEntryType}" "${sv_PlistFilePath}"
    fi
  done
      
  # Set Entry Value    
  /usr/libexec/PlistBuddy >/dev/null 2>&1 -c "Set '${sv_PropertyName}' '${sv_EntryValue}'" "${sv_PlistFilePath}"
#echo /usr/libexec/PlistBuddy -c "Set '${sv_PropertyName}' '${sv_EntryValue}'" "${sv_PlistFilePath}"
  if [ $? -ne 0 ]
  then
    LW_nf_logmessage "ERROR, failed to set property ${sv_PropertyName} in ${sv_PlistFilePath}"
  fi

}

# Get a property value from a plist file
LW_sf_GetPlistProperty()   # plistfile property [defaultvalue]
{
  local sv_PlistFilePath
  local sv_PropertyName
  local sv_DefaultValue
  local sv_EntryValue

  sv_PlistFilePath="${1}"
  sv_PropertyName="${2}"
  sv_DefaultValue="${3}"

  sv_EntryValue=$(/usr/libexec/PlistBuddy 2>/dev/null -c "Print '${sv_PropertyName}'" "${sv_PlistFilePath}")
  if [ $? -ne 0 ]
  then
    if [ $# -eq 3 ]
    then
      LW_nf_SetPlistProperty "${sv_PlistFilePath}" "${sv_PropertyName}" "${sv_DefaultValue}"

      sv_EntryValue=$(/usr/libexec/PlistBuddy 2>/dev/null -c "Print ':${sv_PropertyName}'" "${sv_PlistFilePath}")
      if [ $? -ne 0 ]
      then
        LW_nf_logmessage "NOTE, failed to get property ${sv_PropertyName} from ${sv_PlistFilePath}"
      fi
    else
      LW_nf_logmessage "NOTE, failed to get property ${sv_PropertyName} from ${sv_PlistFilePath}"
    fi
  fi

  echo -n "${sv_EntryValue}"
}

# Schedule event for specified EPOCH time. Identify the event with a unique TAG.
# WAKETYPE can be one of sleep, wake, poweron, shutdown, wakeorpoweron
LW_nf_schedule4epoch()   # TAG WAKETYPE EPOCH
{
  local iv_SchedEpoch
  local sv_SchedLine
  local iv_NowEpoch

  sv_Tag=${1}
  sv_WakeType=${2}
  iv_SchedEpoch=${3}

  iv_NowEpoch=$(date -u "+%s")

  if [ ${iv_NowEpoch} -lt ${iv_SchedEpoch} ]
  then
    # check there isnt a named scheduled already
    pmset -g sched | grep -i "${sv_WakeType}" | grep -i "${sv_Tag}" | tr -s " " | cut -d " " -f5-6 | while read sv_SchedLine
    do
      pmset schedule cancel ${sv_WakeType} "${sv_SchedLine}" "${sv_Tag}" 2>/dev/null
    done

    sv_SchedLine=$(date -r ${iv_SchedEpoch} "+%m/%d/%y %H:%M:%S")
    pmset schedule ${sv_WakeType} "${sv_SchedLine}" "${sv_Tag}"
  fi
}

# Takes a uri, and returns a local filename.
# Remote files (http, ftp, smb), will be downloaded to a local file.
# The returned filename may or may not exist
# Has got quite complex - Wish it was simpler
LW_sf_ResolveFilename()   # fileuri - if fileuri ends in a / it is assumed to be a dir, otherwise it is assumed to be a file
{

  local bv_IsDir
  local sv_DstFilePath
  local sv_ExistingMountDirPath
  local sv_FileURI
  local sv_Host
  local sv_KUser
  local sv_KprincipalAfter
  local sv_KprincipalBefore
  local sv_RemoteConn
  local sv_RemoteDirPath
  local sv_SrcFileName
  local sv_SrcFilePath
  local sv_SrcFileProtocol
  local sv_SrcMountDirPath
  local sv_SrvrConnHost
  local sv_SrvrConnPass
  local sv_SrvrConnString
  local sv_SrvrConnUser
  local sv_TempDirPath
    
  sv_FileURI=${1}

  sv_SrcFileProtocol=$(echo ${sv_FileURI} | cut -d ":" -f1)    
  sv_SrcFileName="$(basename "${sv_FileURI}")"
   
  if test -n "$(echo ${sv_FileURI} | grep -E ".*/$")"
  then
    bv_IsDir="true"
  else
    bv_IsDir="false"
  fi

  case "$sv_SrcFileProtocol" in
  file)
    sv_Host=$(echo $sv_FileURI | cut -d "/" -f3 | tr "[A-Z]" "[a-z]" )
    if [ "$sv_Host" = "localhost" -o "$sv_Host" = "" ]
    then
      sv_SrcFilePath="/"$(echo $sv_FileURI | cut -d "/" -f4-)
      sv_DstFilePath="${sv_SrcFilePath}"
    fi
    ;;

  http|https|ftp)
    sv_TempDirPath="$(mktemp -dq ${LW_sv_ThisUserTempDirPath}/${LW_sv_ThisScriptFileName}-Resolved-XXXXXXXX)"
    sv_DstFilePath="${sv_TempDirPath}/${sv_SrcFileName}"
      
    curl --max-time 120 --connect-timeout 10 -s -S "${sv_FileURI}" > "$sv_DstFilePath"
    ;;

  smb)
    # Get Kerberos principal before the mount
    sv_KprincipalBefore="$(klist 2>/dev/null | grep "Principal:" | head -n1 | cut -d":" -f2 | sed "s|^[ ]*||")"
    
    # Get Kerberos user (if any)
    sv_KUser="$(echo "${sv_KprincipalBefore}" | cut -d"@" -f1)"

    # Get User, Password & Host
    sv_SrvrConnString="$(echo ${sv_FileURI} | cut -d"/" -f3)"
    sv_SrvrConnHost="$(echo ${sv_SrvrConnString} | cut -sd"@" -f2)"
    if test -z "${sv_SrvrConnHost}"
    then
      sv_SrvrConnHost="${sv_SrvrConnString}"
      sv_SrvrConnPass=""
      if test -n "${sv_KUser}"
      then
        sv_SrvrConnUser="${sv_KUser}"
      else
        sv_SrvrConnUser="Guest"
        
        if [ "${LW_sv_ThisUserName}" = "root" ]
        then
          if test -n "${LW_sv_ADTrustAccount}"
          then
            sv_SrvrConnUser="${LW_sv_ADTrustAccount}"
            sv_SrvrConnPass="${LW_sv_ADTrustPassword}"   
          fi
        fi   

      fi
      
    else
      sv_SrvrConnString="$(echo ${sv_SrvrConnString} | cut -d"@" -f1)"
      sv_SrvrConnPass="$(echo ${sv_SrvrConnString} | cut -sd":" -f2)"
      if test -z "${sv_SrvrConnPass}"
      then
        sv_SrvrConnUser="${sv_SrvrConnString}"
        sv_SrvrConnPass=""
      else
        sv_SrvrConnUser="$(echo ${sv_SrvrConnString} | cut -d":" -f1)" 
      fi
    fi
    sv_SrvrConnPass=$(LW_sf_urlencode "${sv_SrvrConnPass}")

    
    sv_RemoteDirPath="$(echo ${sv_FileURI} | cut -d "/" -f4- | sed "s|/$||")"
    if [ "${bv_IsDir}" = "false" ]
    then
      sv_RemoteDirPath="$(dirname "${sv_RemoteDirPath}")"
    fi    
    
    sv_ExistingMountDirPath=$(mount | grep " (smbfs," | grep -i "//${sv_SrvrConnUser}@${sv_SrvrConnHost}/${sv_RemoteDirPath}" | sed -E "s|(.*)(\(smbfs,).*|\1|;s|(.*) on (.*)|\2|;s|[ ]*$||")

	if test -n "${sv_ExistingMountDirPath}"
	then
	  sv_SrcMountDirPath="${sv_ExistingMountDirPath}"
	  
	else
	
	  # Decide where we will mount the remote directory
      sv_SrcMountDirPath="$(mktemp -dq ${LW_sv_ThisUserTempDirPath}/${LW_sv_ThisScriptFileName}-Mount-XXXXXXXX)"

	  # Build a connection string
      if test -z "${sv_SrvrConnUser}"
      then
        sv_RemoteConn="//${sv_SrvrConnHost}/${sv_RemoteDirPath}"
      else
        if test -z "${sv_SrvrConnPass}"
        then
          sv_RemoteConn="//${sv_SrvrConnUser}@${sv_SrvrConnHost}/${sv_RemoteDirPath}"
        else
          sv_RemoteConn="//${sv_SrvrConnUser}:${sv_SrvrConnPass}@${sv_SrvrConnHost}/${sv_RemoteDirPath}"
        fi
      fi
      
      # echo DEBUG /sbin/mount_smbfs -N "${sv_RemoteConn}" "${sv_SrcMountDirPath}"
      if ! /sbin/mount_smbfs 2>/dev/null -N "${sv_RemoteConn}" "${sv_SrcMountDirPath}"
      then
        # Mount failed
        
        # Make double sure it's not mounted
        if [ "$(stat -f%Sd "${sv_SrcMountDirPath}")" = "$(stat -f%Sd "/")" ]
        then
          # Only delete it if its empty
          rmdir "${sv_SrcMountDirPath}"
          sv_SrcMountDirPath=""
        fi
      fi    
    
    fi

    if test -n "${sv_SrcMountDirPath}"
    then
      # Remote directory is mounted
      sv_TempDirPath="$(mktemp -dq ${LW_sv_ThisUserTempDirPath}/${LW_sv_ThisScriptFileName}-Resolved-XXXXXXXX)"
      sv_DstFilePath="${sv_TempDirPath}/${sv_SrcFileName}"
      
      if [ "${bv_IsDir}" = "false" ]
      then
        # copy file
        if test -e "${sv_SrcMountDirPath}/${sv_SrcFileName}"
        then
          cp -p "${sv_SrcMountDirPath}/${sv_SrcFileName}" "${sv_DstFilePath}"
        fi
      else
        # copy directory
        mkdir -p "${sv_DstFilePath}"
        cp -pR "${sv_SrcMountDirPath}/" "${sv_DstFilePath}/"
      fi

    fi
    
    if test -z "${sv_ExistingMountDirPath}"
    then
      if test -n "${sv_SrcMountDirPath}"
      then
        # unmount mount, only if it didnt already exist
        # echo DEBUG /sbin/umount "${sv_SrcMountDirPath}"
        /sbin/umount "${sv_SrcMountDirPath}"
        
        # Make double sure it's not mounted
        if [ "$(stat -f%Sd "${sv_SrcMountDirPath}")" = "$(stat -f%Sd "/")" ]
        then
          # Only delete it if its empty
          rmdir "${sv_SrcMountDirPath}"
        fi

      fi
    fi
    
    # Get Kerberos principal after all this kerfuffle
    sv_KprincipalAfter="$(klist 2>/dev/null | grep "Principal:" | head -n1 | cut -d":" -f2 | sed "s|^[ ]*||")"
    
    # If there is a new Kerberos principal - destroy it
    if [ "${sv_KprincipalAfter}" != "${sv_KprincipalBefore}" ]
    then
      kdestroy
    fi

    ;;

  afp)
    ;;

  *)
    # assume that we were passed a path rather than a uri
    sv_DstFilePath="${sv_FileURI}"
    ;;

  esac	    

  if test -n "${sv_DstFilePath}"
  then
    # check that file exists
    if ! test -e "${sv_DstFilePath}"
    then
      sv_DstFilePath=""
    fi
  fi
    
  echo "${sv_DstFilePath}"
}

LW_nf_TriggerEvent() # <eventHistory> <event> [OptionalParam]
{
  local bv_EventHasPolicies
  local iv_DoesTriggerCount
  local sv_ConfigDirPath
  local sv_EventHistory
  local sv_EventName
  local sv_OptionalParam
  local sv_PolicyFilePath
  local sv_PolicyName
  
  # Get (full) event History
  sv_EventHistory="${1}"

  # Get event that triggered this policy
  sv_EventName="${2}"

  # Get optional parameter
  sv_OptionalParam="${3}"
 
  LW_nf_logmessage "NOTE, event occured: '${sv_EventHistory}:${sv_EventName}' '${LW_sv_LoggedInUserName}' '${sv_OptionalParam}' as user '${LW_sv_ThisUserName}' "

  mkdir -p "${LW_sv_ThisUserTempDirPath}/ActiveEvents"
  
  # Make sure a badly defined config doesnt put us in an endless trigger loop
  if test -n "$(echo ${sv_EventHistory} | tr ":" "\n" | grep -E "^"${sv_EventName}"$")"
  then
    LW_nf_logmessage "ERROR, event loop in config"
    
  else
    # Flag that there is an event in process
    touch "${LW_sv_ThisUserTempDirPath}/ActiveEvents/${sv_EventName}"
    
    bv_EventHasPolicies="false"
    
    if test -n "${LW_sv_LoggedInUserName}"
    then
      # Run through the user policies
      sv_ConfigDirPath="${LW_sv_SettingsDirPath}/Config/Users/${LW_sv_LoggedInUserName}"
      iv_DoesTriggerCount="$(LW_if_GetPlistArraySize "${sv_ConfigDirPath}/LabWarden.plist" ":${sv_EventName}:DoesTrigger")"
      for (( iv_DoesTriggerIndex=0; iv_DoesTriggerIndex<${iv_DoesTriggerCount}; iv_DoesTriggerIndex++ ))
      do
        sv_PolicyName=$(LW_sf_GetPlistProperty "${sv_ConfigDirPath}/LabWarden.plist" ":${sv_EventName}:DoesTrigger:${iv_DoesTriggerIndex}")
        if test -n "${sv_PolicyName}"
        then
          sv_PolicyFilePath="/usr/local/LabWarden/Policies/custom/${sv_PolicyName}"
          if ! test -e "${sv_PolicyFilePath}"
          then
            sv_PolicyFilePath="/usr/local/LabWarden/Policies/${sv_PolicyName}"
            if ! test -e "${sv_PolicyFilePath}"
            then
              sv_PolicyFilePath="/usr/local/LabWarden/Policies/legacy/${sv_PolicyName}"
              if ! test -e "${sv_PolicyFilePath}"
              then
                sv_PolicyFilePath=""
              fi
            fi
          fi
          if test -n "${sv_PolicyFilePath}"
          then
            # Run script in background
            "${sv_PolicyFilePath}" "${sv_ConfigDirPath}" "${sv_EventHistory}:${sv_EventName}" "${LW_sv_LoggedInUserName}" "${sv_OptionalParam}" &
            bv_EventHasPolicies="true"
          fi
        fi
      done
    fi

    # Run through the workstation policies
    sv_ConfigDirPath="${LW_sv_SettingsDirPath}/Config/Computers/${LW_sv_ADComputerName}"
    iv_DoesTriggerCount="$(LW_if_GetPlistArraySize "${sv_ConfigDirPath}/LabWarden.plist" ":${sv_EventName}:DoesTrigger")"
    for (( iv_DoesTriggerIndex=0; iv_DoesTriggerIndex<${iv_DoesTriggerCount}; iv_DoesTriggerIndex++ ))
    do
      sv_PolicyName=$(LW_sf_GetPlistProperty "${sv_ConfigDirPath}/LabWarden.plist" ":${sv_EventName}:DoesTrigger:${iv_DoesTriggerIndex}")
      if test -n "${sv_PolicyName}"
      then
        sv_PolicyFilePath="/usr/local/LabWarden/Policies/custom/${sv_PolicyName}"
        if ! test -e "${sv_PolicyFilePath}"
        then
          sv_PolicyFilePath="/usr/local/LabWarden/Policies/${sv_PolicyName}"
          if ! test -e "${sv_PolicyFilePath}"
          then
            sv_PolicyFilePath="/usr/local/LabWarden/Policies/legacy/${sv_PolicyName}"
            if ! test -e "${sv_PolicyFilePath}"
            then
              sv_PolicyFilePath=""
            fi
          fi
        fi
        if test -n "${sv_PolicyFilePath}"
        then
          # Run script in background
          "${sv_PolicyFilePath}" "${sv_ConfigDirPath}" "${sv_EventHistory}:${sv_EventName}" "${LW_sv_LoggedInUserName}" "${sv_OptionalParam}" &
          bv_EventHasPolicies="true"
        fi
     fi
    done
    
    if [ "${bv_EventHasPolicies}" = "false" ]
    then
      LW_nf_logmessage "NOTE, event ignored: '${sv_EventHistory}:${sv_EventName}' '${LW_sv_LoggedInUserName}' '${sv_OptionalParam}' as user '${LW_sv_ThisUserName}' (no associated policy)"
    fi
  
    # We dont want to quit until the background scripts are finished or they might terminate early
    while [ -n "$(jobs -r)" ]
    do
      # we don't want to hog the CPU - so lets sleep a while
      sleep 1
    done

    # Flag that there the event has finished
    rm -f "${LW_sv_ThisUserTempDirPath}/ActiveEvents/${sv_EventName}"
  fi
}

# -- End Function Definition --

# -- Get some info about this script

# Full source of this script
LW_sv_ThisScriptFilePath="${0}"

# Get dir of this script
LW_sv_ThisScriptDirPath="$(dirname "${LW_sv_ThisScriptFilePath}")"

# Get filename of this script
LW_sv_ThisScriptFileName="$(basename "${LW_sv_ThisScriptFilePath}")"

# Filename without extension
LW_sv_ThisScriptName="$(echo ${LW_sv_ThisScriptFileName} | sed 's|\.[^.]*$||')"

# Get Process ID of this script
LW_iv_ThisScriptPID=$$

# -- Get some info about the OS

# Last OS X version would probably be 10.255.25 (259Z2047)

# Calculate BuildVersionStampAsNumber

LW_sv_BuildVersionStampAsString="$(sw_vers -buildVersion)"

# Split build version (eg 14A379a) into parts (14,A,379,a)
iv_BuildMajorNum=$(echo ${LW_sv_BuildVersionStampAsString} | sed "s|[a-zA-Z][0-9]*||;s|[a-zA-Z]*$||")
sv_BuildMinorChar=$(echo ${LW_sv_BuildVersionStampAsString} | sed "s|^[0-9]*||;s|[0-9]*[a-zA-Z]*$||")
iv_BuildRevisionNum=$(echo ${LW_sv_BuildVersionStampAsString} | sed "s|^[0-9]*[a-zA-Z]||;s|[a-zA-Z]*$||")
sv_BuildStageChar=$(echo ${LW_sv_BuildVersionStampAsString} | sed "s|^[0-9]*[a-zA-Z][0-9]*||")

iv_BuildMinorNum=$(($(printf "%d" "'${sv_BuildMinorChar}")-65))
if [ -n "${sv_BuildStageChar}" ]
then
  iv_BuildStageNum=$(($(printf "%d" "'${sv_BuildStageChar}")-96))
else
  iv_BuildStageNum=0
fi

LW_iv_BuildVersionStampAsNumber=$((((${iv_BuildMajorNum}*32+${iv_BuildMinorNum})*2048+${iv_BuildRevisionNum})*32+${iv_BuildStageNum}))

# Calculate SystemVersionStampAsNumber

LW_sv_SystemVersionStampAsString="$(sw_vers -productVersion)"

LW_iv_SystemVersionStampAsNumber=0
for iv_Num in $(echo ${LW_sv_SystemVersionStampAsString}".0.0.0.0" | cut -d"." -f1-4 | tr "." "\n")
do
  LW_iv_SystemVersionStampAsNumber=$((${LW_iv_SystemVersionStampAsNumber}*256+${iv_Num}))
done

# -- Get some info about the running user

# Get user name
LW_sv_ThisUserName="$(whoami)"

# Get user ID
LW_iv_ThisUserID="$(id -u ${LW_sv_ThisUserName})"

# Only allow specifying a different logged in user, if we are root
if [ "${LW_sv_ThisUserName}" != "root" ]
then
  LW_sv_LoggedInUserName="${LW_sv_ThisUserName}"
fi

# -- Get some info about the logged in user

if test -n "${LW_sv_LoggedInUserName}"
then

  # Get user ID
  LW_iv_LoggedInUserID="$(id -u ${LW_sv_LoggedInUserName})"

  # Check if user is an admin (returns "true" or "false")
  if [ "$(dseditgroup -o checkmember -m "${LW_sv_LoggedInUserName}" -n . admin | cut -d" " -f1)" = "yes" ]
  then
    LW_bv_LoggedInUserIsAdmin="true"
  else
    LW_bv_LoggedInUserIsAdmin="false"
  fi

  # Check if user is a local account (returns "true" or "false")
  if [ "$(dseditgroup -o checkmember -m "${LW_sv_LoggedInUserName}" -n . localaccounts | cut -d" " -f1)" = "yes" ]
  then
    LW_bv_LoggedInUserIsLocal="true"
  else
    LW_bv_LoggedInUserIsLocal="false"
  fi

  if test -n "$(dscl 2>/dev/null localhost -read /Local/Default/Users/${LW_sv_LoggedInUserName} OriginalHomeDirectory)"
  then
    LW_bv_LoggedInUserIsMobile="true"
  else
    LW_bv_LoggedInUserIsMobile="false"
  fi

  # Get the User Home directory
  LW_sv_LoggedInUserHomeDirPath=$(eval echo ~${LW_sv_LoggedInUserName})

  # Decide whether the user home is on the local drive
  if test -n "$(stat -f "%Sd" "${LW_sv_LoggedInUserHomeDirPath}" | grep "^disk")"
  then
    LW_bv_LoggedInUserHomeIsLocal="true"
  else
    LW_bv_LoggedInUserHomeIsLocal="false"
  fi

  # Get the network defined home directory
  if [ "${LW_bv_LoggedInUserIsLocal}" = "false" ]
  then
    # - Network account -

    # Get UserHomeNetworkURI 
    # ie: smb://yourserver.com/staff/t/testuser
    # or  smb://yourserver.com/Data/Student%20Homes/Active_Q2/pal/teststudpal

    LW_sv_LoggedInUserHomeNetworkURI=$(dscl 2>/dev/null localhost -read /Search/Users/${LW_sv_LoggedInUserName} HomeDirectory | sed "s|HomeDirectory: ||;s|<[^>]*>||g;s|/$||;s|^[^:]*:||")
    if test -z "${LW_sv_LoggedInUserHomeNetworkURI}"
    then
      LW_sv_LoggedInUserHomeNetworkURI=$(dscl 2>/dev/null localhost -read /Search/Users/${LW_sv_LoggedInUserName} OriginalHomeDirectory | sed "s|OriginalHomeDirectory: ||;s|<[^>]*>||g;s|/$||")
  
    fi  
  
    if test -n "${LW_sv_LoggedInUserHomeNetworkURI}"
    then
      # The user home directory has been forced from the network to a local drive

      # Get full path to the network HomeDirectory 
      # ie: /Volumes/staff/t/testuser
      # or  /Volumes/Data/Student Homes/Active_Q2/pal/teststudpal
      while read sv_MountEntry
      do
        sv_MountPoint=$(echo ${sv_MountEntry} | sed -E 's|(^.*) on (.*) (\(.*\))|\2|' | grep -v '^/$')
        sv_MountShare=$(echo ${sv_MountEntry} | sed -E 's|(^.*) on (.*) (\(.*\))|\1|' | sed 's|'${LW_sv_LoggedInUserName}'@||')
        if test -n "$(echo "${LW_sv_LoggedInUserHomeNetworkURI}" | sed "s|^[^:]*:||" | grep -E "^${sv_MountShare}")"
        then
          LW_sv_LoggedInUserHomeNetworkDirPath=$(LW_sf_urldecode "${sv_MountPoint}$(echo ${LW_sv_LoggedInUserHomeNetworkURI} | sed "s|^[^:]*:||;s|^"${sv_MountShare}"||")")
          break
        fi
      done < <(mount | grep "//${LW_sv_LoggedInUserName}@")
    
    fi
  fi

  # Where would the user home normally be if it were local
  if [ "${LW_sv_LoggedInUserName}" = "root" ]
  then
    LW_sv_LoggedInUserLocalHomeDirPath="/var/root"

  else
    LW_sv_LoggedInUserLocalHomeDirPath="/Users/${LW_sv_LoggedInUserName}"
    
  fi

fi


# -- Decide various folder locations

# Path to useful binaries
LW_sv_BinDirPath=/usr/local/LabWarden/bin

# ---

# Create a temporary directory private to this user (and admins)
LW_sv_ThisUserTempDirPath=/tmp/${LW_sv_ThisUserName}
if ! test -d "${LW_sv_ThisUserTempDirPath}"
then
  mkdir -p "${LW_sv_ThisUserTempDirPath}"
  chown ${LW_sv_ThisUserName}:admin "${LW_sv_ThisUserTempDirPath}"
  chmod 770 "${LW_sv_ThisUserTempDirPath}"
fi

# Create a temporary directory private to this script
LW_sv_ThisScriptTempDirPath="$(mktemp -dq ${LW_sv_ThisUserTempDirPath}/${LW_sv_ThisScriptFileName}-XXXXXXXX)"

# -- Get Computer AD credentials

# Get Computer AD trust account - i.e. yourcomputername$
LW_sv_ADTrustAccount="$(dsconfigad 2>/dev/null -show | grep "Computer Account" | sed "s|\([^=]*\)=[ ]*\([^ ]*$\)|\2|")"

# Get Computer AD domain - i.e. your.domain.com
LW_sv_ADDomainNameDNS="$(dsconfigad 2>/dev/null -show | grep "Active Directory Domain" | sed "s|\([^=]*\)=[ ]*\([^ ]*$\)|\2|")"

LW_sv_ADDomainNameFlat=$(echo "show com.apple.opendirectoryd.ActiveDirectory" | scutil | grep "DomainNameFlat" | cut -d":" -f 2- | sed "s|^[ ]*||;s|[ ]*$||")
if test -n "${LW_sv_ADDomainNameFlat}"
then
  LW_sv_ADTrustPassword=$(security find-generic-password -w -s "/Active Directory/${LW_sv_ADDomainNameFlat}" /Library/Keychains/System.keychain)
fi

# AD computer name (without the trailing dollar sign)
LW_sv_ADComputerName=$(echo ${LW_sv_ADTrustAccount} | sed "s|\$$||")

# ---

# Decide where the config/pref/log files go
LW_sv_SettingsDirPath="/Library/Preferences/SystemConfiguration/${LW_sv_LabWardenSignature}"

if [ "${LW_sv_ThisUserName}" = "root" ]
then
  mkdir -p "${LW_sv_SettingsDirPath}/Config/Computers/${LW_sv_ADComputerName}"
  LW_sv_ThisUserLogDirPath="/Library/Logs/${LW_sv_LabWardenSignature}"
  LW_sv_ThisUserPrefDirPath="${LW_sv_SettingsDirPath}/Config/Computers/${LW_sv_ADComputerName}"

else
  LW_sv_ThisUserLogDirPath="${LW_sv_LoggedInUserHomeDirPath}/Library/Logs/${LW_sv_LabWardenSignature}"
  LW_sv_ThisUserPrefDirPath="${LW_sv_LoggedInUserHomeDirPath}/Library/Preferences/${LW_sv_LabWardenSignature}/${LW_sv_ADComputerName}"
  
fi

mkdir -p "${LW_sv_ThisUserPrefDirPath}"
mkdir -p "${LW_sv_ThisUserLogDirPath}"

# -- Get Network info

LW_sv_IPv4PrimaryService=$(echo "show State:/Network/Global/IPv4" | scutil | grep "PrimaryService" | cut -d":" -f 2- | sed "s|^[ ]*||;s|[ ]*$||")
if test -n "${LW_sv_IPv4PrimaryService}"
then
  # Get DHCP option 15 (domain)
  LW_sv_NetworkServiceDHCPOption15=$(echo "show State:/Network/Service/${LW_sv_IPv4PrimaryService}/DHCP" | scutil | grep "Option_15" | cut -d":" -f 2- | sed "s|^[ ]*||;s|[ ]*$||" | sed -E "s/^<data> 0x//;s/00$//" | xxd -r -p)

  # Get user defined name - e.g. Wi-Fi
  LW_sv_NetworkServiceInterfaceName=$(echo "show Setup:/Network/Service/${LW_sv_IPv4PrimaryService}/Interface" | scutil | grep "UserDefinedName" | cut -d":" -f 2- | sed "s|^[ ]*||;s|[ ]*$||")

  # Get device name - e.g. en1
  LW_sv_NetworkServiceInterfaceDevice=$(echo "show Setup:/Network/Service/${LW_sv_IPv4PrimaryService}/Interface" | scutil | grep "DeviceName" | cut -d":" -f 2- | sed "s|^[ ]*||;s|[ ]*$||")

  # Get device hardware - e.g. Airport
  LW_sv_NetworkServiceInterfaceHardware=$(echo "show Setup:/Network/Service/${LW_sv_IPv4PrimaryService}/Interface" | scutil | grep "Hardware" | cut -d":" -f 2- | sed "s|^[ ]*||;s|[ ]*$||")
fi
