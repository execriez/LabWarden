#!/bin/bash
#
# Short:    Sys Policy script - Runs a custom update script
# Author:   Mark J Swift
# Version:  2.0.17
# Modified: 07-Oct-2017
#
# Triggered by the following events:
#   Sys-LoginWindow     (as root)
#   Sys-LoginWindowIdle (as root)
#   Sys-Poll            (as root)
#   Sys-ManualTrigger   (as root)
#
# Called as follows:    
#   Sys-Update <ConfigFilePath> <ConfigEntryName> <EventHistory> <LoggedInUser> <OptionalParam>

# ---

sv_CodeVersion="2.0.17"

if [ $# -eq 0 ]
then
  echo "${sv_CodeVersion}"
  exit 0
fi

# ---

# Get the config file path
sv_ConfigFilePath="${1}"
if test -z "${sv_ConfigFilePath}"
then
  # We need something to work with
  exit 0
fi

# Get config entry name. This is the entry in the config that holds the configurable parameters for this policy.
sv_ConfigEntryName="${2}"

# Get event History
sv_EventHistory="${3}"

# Calculate the event that triggered this policy.
sv_EventName="$(echo ${sv_EventHistory} | tr ":" "\n" | tail -n 1)"
if test -z "${sv_EventName}"
then
  # We need something to work with
  exit 0
fi

# Get the name of the logged in user, a null string signifies no-one is logged in
GLB_sv_LoggedInUserName="${4}"

# Get optional parameter
# This is a general variable that is currently used to pass the following info:
#   Application info during a AppWillLaunch, AppDidLaunch or AppDidTerminate event.
#   User info during a Sys-ConsoleUserLoggedIn, Sys-ConsoleUserLoggedOut, Sys-ConsoleUserSwitch, Sys-Login or Sys-Logout event.
sv_OptionalParam="${5}"

# Get info from optional parameter
case ${sv_EventName} in

Sys-ConsoleUserLoggedIn|Sys-ConsoleUserLoggedOut|Sys-ConsoleUserSwitch|Sys-Login|Sys-Logout)
  GLB_sv_LoggedInUserName="${sv_OptionalParam}"
  ;;
  
esac

# ---

# Load the library, only if it is not already loaded
if test -z "${GLB_sv_ProjectSignature}"
then
  . /usr/local/LabWarden/inc/Common.sh
fi

# By the time we get here, quite a few global variables have been set up.
# Look at 'CommonLib' for a complete list.

# ---

# Get policy name (Name of this script)
sv_PolicyName="${GLB_sv_ThisScriptName}"

# ---

# Calculate the pref file paths

# Local prefs are referenced by Policy UUID and are local to the running user. These are deleted when the policy is updated or uninstalled.
sv_ThisUserLocalPrefFilePath="${GLB_sv_ThisUserPrefDirPath}/${sv_ConfigEntryName}.plist"

# Global prefs are referenced by Policy Name and are read/write root but read-only for normal users. These survive policy updates and uninstalls.
sv_ThisPolicyGlobalPrefFilePath="${GLB_sv_ProjectConfigDirPath}/Config/Global/${sv_PolicyName}.plist"

# ---

# Usr-PolicyInstall & Usr-PolicyUninstall events (which are called as a normal user) are ignored by system policies

if [ "${sv_EventName}" = "Usr-PolicyInstall" ] || [ "${sv_EventName}" = "Usr-PolicyUninstall" ]
then
  GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Event '${sv_EventHistory}' ignored by policy '${sv_PolicyName}'"
  exit 0
fi

# ---

# check config "ActiveForDomain" setting to see if we are active or not. Can pass an optional subkey.
bf_OptionIsActiveForThisDomain() # [subkey]
{
  local bv_IsActive
  local iv_IsActiveForDomainCount
  local sv_IsActiveForDomain
  
  sv_SubKey="${1}"
  if test -n "${sv_SubKey}" 
  then
    # add a single colon to the subkey
    sv_SubKey=$(echo "${sv_SubKey}:" | sed "s|[:]*$|:|")
  fi
  
  # Note, config "ActiveForDomain" value can be null, ALL, NONE, ADDOMAIN or your.company.domain

  bv_IsActive="false"
  iv_IsActiveForDomainCount="$(GLB_if_GetPlistArraySize "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:${sv_SubKey}ActiveForDomain")"
  for (( iv_IsActiveForDomainIndex=0; iv_IsActiveForDomainIndex<${iv_IsActiveForDomainCount}; iv_IsActiveForDomainIndex++ ))
  do
    sv_IsActiveForDomain=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:${sv_SubKey}ActiveForDomain:${iv_IsActiveForDomainIndex}")
    if test -n "${sv_IsActiveForDomain}"
    then
      case ${sv_IsActiveForDomain} in
      ALL)
        bv_IsActive="true"
        break 2
        ;;
        
      NONE)
        break 2
        ;;
        
      ADDOMAIN)
        sv_IsActiveForDomain="${GLB_sv_ADDomainNameDNS}"
        ;;
          
      esac
    fi
    
    if [ "${sv_IsActiveForDomain}" = "${GLB_sv_NetworkServiceDHCPOption15}" ]
    then
      bv_IsActive="true"
      break
    fi
  done
  
  echo "${bv_IsActive}"
}

bf_UpdatesAllowed() # returns true if updates are allowed to run right now
{
  local iv_CurrOutOfHoursStartTime
  local iv_CurrOutOfHoursStartHour
  local iv_CurrOutOfHoursStartMinute
  local iv_CurrOutOfHoursStartEpoch
  local iv_CurrOutOfHoursEndTime
  local iv_CurrOutOfHoursEndHour
  local iv_CurrOutOfHoursEndMinute
  local iv_CurrOutOfHoursEndEpoch
  local iv_LastUpdateEpoch
  local bv_DoUpdate
  local bv_OutOfHoursPowerOn
  local iv_NextUpdateEpoch
  local iv_NextOutOfHoursStartEpoch
  local iv_NextOutOfHoursEndEpoch
  local iv_NextOutOfHoursUpdateEpoch
  
  iv_CurrOutOfHoursStartTime=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:OutOfHoursStartTime" | grep -E "^[0-9]{1,2}:[0-9]{2}$")
  if test -n "${iv_CurrOutOfHoursStartTime}"
  then
    # Get update start time before now
    iv_CurrOutOfHoursStartHour=$(echo "${iv_CurrOutOfHoursStartTime}" | cut -d":" -f1)
    iv_CurrOutOfHoursStartMinute=$(echo "${iv_CurrOutOfHoursStartTime}" | cut -d":" -f2)
    iv_CurrOutOfHoursStartEpoch=$(date -r ${GLB_iv_ThisScriptStartEpoch} -v${iv_CurrOutOfHoursStartHour}H -v${iv_CurrOutOfHoursStartMinute}M -v0S "+%s")

    if [ ${GLB_iv_ThisScriptStartEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
    then
      iv_CurrOutOfHoursStartEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v-1d "+%s")
    fi

    iv_CurrOutOfHoursEndTime=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:OutOfHoursEndTime" | grep -E "^[0-9]{1,2}:[0-9]{2}$")
    if test -n "${iv_CurrOutOfHoursEndTime}"
    then
      iv_CurrOutOfHoursEndHour=$(echo "${iv_CurrOutOfHoursEndTime}" | cut -d":" -f1)
      iv_CurrOutOfHoursEndMinute=$(echo "${iv_CurrOutOfHoursEndTime}" | cut -d":" -f2)
      iv_CurrOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v${iv_CurrOutOfHoursEndHour}H -v${iv_CurrOutOfHoursEndMinute}M -v0S "+%s")

      if [ ${iv_CurrOutOfHoursEndEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
      then
        iv_CurrOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursEndEpoch} -v+1d "+%s")
      fi
        
      # Adjust end to allow at least one Sys-LoginWindowPoll to happen - if an update is scheduled at the end of the out-of-hours period
      iv_CurrOutOfHoursEndEpoch=$((${iv_CurrOutOfHoursEndEpoch}-${GLB_iv_SysLoginWindowPollTriggerSecs}*2))
      if [ ${iv_CurrOutOfHoursEndEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
      then
        # The defined period is clearly not long enough, so null the value
        iv_CurrOutOfHoursEndEpoch=""
      fi

    fi
  fi

  if test -z "${iv_CurrOutOfHoursEndEpoch}"
  then
    # The defined period is unset or invalid, so assume it's OK between 3:00am and 4:00am
    iv_CurrOutOfHoursStartEpoch=$(date -r ${GLB_iv_ThisScriptStartEpoch} -v3H -v0M -v0S "+%s")
    if [ ${GLB_iv_ThisScriptStartEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
    then
      iv_CurrOutOfHoursStartEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v-1d "+%s")
    fi
    
    iv_CurrOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v4H -v0M -v0S "+%s")
    if [ ${iv_CurrOutOfHoursEndEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
    then
      iv_CurrOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursEndEpoch} -v+1d "+%s")
    fi
  fi

  if [ ${GLB_iv_ThisScriptStartEpoch} -lt ${iv_CurrOutOfHoursEndEpoch} ]
  then
    iv_LastUpdateEpoch=$(GLB_sf_GetPlistProperty "${sv_ThisPolicyGlobalPrefFilePath}" ":${sv_PolicyName}:GlobalPrefs:LastUpdateEpoch")
    if test -z "${iv_LastUpdateEpoch}"
    then
      iv_LastUpdateEpoch=0
    fi
      
    if [ ${iv_LastUpdateEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "We are out-of-hours, so updates are enabled"
      bv_DoUpdate="true"
        
    else
      GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "An update has recently happened, so updates are disabled"
      bv_DoUpdate="false"
        
    fi
      
  else
    GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "We are within working hours, so updates are disabled"
    bv_DoUpdate="false"
      
  fi

  if [ "${bv_DoUpdate}" = "false" ]
  then
    iv_LastUpdateEpoch=$(GLB_sf_GetPlistProperty "${sv_ThisPolicyGlobalPrefFilePath}" ":${sv_PolicyName}:GlobalPrefs:LastUpdateEpoch")
    if test -z "${iv_LastUpdateEpoch}"
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Updates have never run, so updates have been enabled"
      bv_DoUpdate="true"
    fi
  fi

  bv_OutOfHoursPowerOn=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:OutOfHoursPowerOn")
  if [ "${bv_OutOfHoursPowerOn}" = "true" ]
  then
    # Get the existing next scheduled update value
    iv_NextUpdateEpoch=$(GLB_sf_GetPlistProperty "${sv_ThisPolicyGlobalPrefFilePath}" ":${sv_PolicyName}:GlobalPrefs:NextUpdateEpoch")
    if test -z "${iv_NextUpdateEpoch}"
    then
      iv_NextUpdateEpoch=0
    fi

    # Check if the next scheduled update has already passed, and if so schedule another one
    if [ ${GLB_iv_ThisScriptStartEpoch} -ge ${iv_NextUpdateEpoch} ]
    then
      # -- work out a good random-ish time to power on for the next Update
      iv_NextOutOfHoursStartEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v+1d "+%s")
      iv_NextOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursEndEpoch} -v+1d "+%s")
      iv_NextOutOfHoursUpdateEpoch=$(jot -r 1 ${iv_NextOutOfHoursStartEpoch} ${iv_NextOutOfHoursEndEpoch})
      GLB_nf_SetPlistProperty "${sv_ThisPolicyGlobalPrefFilePath}" ":${sv_PolicyName}:GlobalPrefs:NextUpdateEpoch" "${iv_NextOutOfHoursUpdateEpoch}"
      GLB_nf_schedule4epoch "${GLB_sv_ThisScriptFileName}" "poweron" ${iv_NextOutOfHoursUpdateEpoch}

      GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Next update will likely be $(date -r ${iv_NextOutOfHoursUpdateEpoch} "+%Y%m%d-%H:%M.%S")"
    fi
      
  else
    GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "PowerOn updates aren't scheduled"
      
  fi

  echo "${bv_DoUpdate}"
}

nf_DoUpdate()
{
  local bv_UpdateScriptActive
  local iv_UpdateExeArgCount
  local sv_UpdateExeURI
  local sv_UpdateExeFilePath
  local iv_UpdateExeArgIndex
  
  # Note, only active when on the specified domain(s) - can be null, ALL, NONE, ADDOMAIN or your.company.domain
  bv_UpdateScriptActive=$(bf_OptionIsActiveForThisDomain "UpdateScript")
    
  if [ "${bv_UpdateScriptActive}" = "false" ]
  then
    GLB_nf_logmessage ${GLB_iv_MsgLevelWarn} "Update skipped - not on a known network."
      
  else
    iv_UpdateExeArgCount="$(GLB_if_GetPlistArraySize "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:UpdateScript:Exe")"
    if [ ${iv_UpdateExeArgCount} -eq 0 ]
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelWarn} "Update skipped - there are no defined update arguments."

    else
      sv_UpdateExeURI="$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:UpdateScript:Exe:0")"
      if test -n "${sv_UpdateExeURI}"
      then
        sv_UpdateExeFilePath=$(GLB_sf_ResolveFileURItoPath "${sv_UpdateExeURI}")
        if ! test -e "${sv_UpdateExeFilePath}"
        then
          # Its possible that we are assuming the lib directory
          sv_UpdateExeFilePath="/usr/local/LabWarden/lib/${sv_UpdateExeURI}"
        fi

        if ! test -e "${sv_UpdateExeFilePath}"
        then
          GLB_nf_logmessage ${GLB_iv_MsgLevelWarn} "Update skipped - update script does not exist (${sv_UpdateExeFilePath})"

        else
          if ! test -x "${sv_UpdateExeFilePath}"
          then
            chown root:wheel "${sv_UpdateExeFilePath}"
            chmod u+x "${sv_UpdateExeFilePath}"
          fi
          for (( iv_UpdateExeArgIndex=1; iv_UpdateExeArgIndex<${iv_UpdateExeArgCount}; iv_UpdateExeArgIndex++ ))
          do
            sv_UpdateExeFilePath="${sv_UpdateExeFilePath} '""$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:UpdateScript:Exe:${iv_UpdateExeArgIndex}")""'"
          done

          # Do a software update
          GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Running update (${sv_UpdateExeFilePath})"
          eval "${sv_UpdateExeFilePath}"

          GLB_nf_SetPlistProperty "${sv_ThisPolicyGlobalPrefFilePath}" ":${sv_PolicyName}:GlobalPrefs:LastUpdateEpoch" "${GLB_iv_ThisScriptStartEpoch}"
        fi
      fi
    fi
      
    GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Ideally we should restart now"
  fi
  
}

# ---

# Execute the Policy

# Take a note of the Policy call
GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Policy '${sv_PolicyName}' ${sv_OptionalParam} triggered by event '${sv_EventHistory}' as user '${GLB_sv_ThisUserName}'"

# ---

# Exit if we are not root
if [ "${GLB_sv_ThisUserName}" != "root" ]
then
  GLB_nf_QuickExit "Policy aborted - User '${GLB_sv_ThisUserName}' is not supported by policy '${sv_PolicyName}'"
fi

# ---

case ${sv_EventName} in
    
Sys-PolicyInstall|Sys-LoginWindow|Sys-Poll)
  # This function returns true if updates are allowed, and schedules a poweron for the next update if necessary
  bv_DoUpdate=$(bf_UpdatesAllowed)
  ;;
    
Sys-ManualTrigger)
  # Manual update requested via /usr/local/LabWarden/util/Update
  GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Running a manual Update."
  
  # Perform a workstation update (software and group policies)
  nf_DoUpdate

  # Do a full group policy update
  GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Updating group policies (via gpupdate)."
  /usr/local/LabWarden/util/gpupdate "-force"
  ;;
  
Sys-LoginWindowIdle)
  # This function returns true if updates are allowed, and schedules a poweron for the next update if necessary
  bv_DoUpdate=$(bf_UpdatesAllowed)

  iv_IdleSecs=$(GLB_if_SystemIdleSecs)
  GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Workstation Idle for ${iv_IdleSecs} secs"

  iv_LoginWindowIdleShutdownSecs=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:LoginWindowIdleShutdownSecs")
  if test -z "${iv_LoginWindowIdleShutdownSecs}"
  then
    iv_LoginWindowIdleShutdownSecs=0
    bv_DoUpdate="false"
  fi

  if [ ${iv_LoginWindowIdleShutdownSecs} -gt 0 ]
  then
    if [ ${iv_IdleSecs} -lt ${iv_LoginWindowIdleShutdownSecs} ]
    then
      bv_DoUpdate="false"  
    fi
  fi

  if [ "${bv_DoUpdate}" = "true" ]
  then
    nf_DoUpdate
    GLB_nf_CreateNamedFlag "Restart"
  fi

  if [ ${iv_LoginWindowIdleShutdownSecs} -gt 0 ]
  then
    if [ ${iv_IdleSecs} -gt ${iv_LoginWindowIdleShutdownSecs} ]
    then
      # Do a full group policy update
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Updating group policies (via gpupdate)."
      /usr/local/LabWarden/util/gpupdate "-force"

      # Shutdown if the workstation is still idle
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Workstation has been idle too long - we should shutdown"
      GLB_nf_CreateNamedFlag "Shutdown"
    fi
  fi
  ;;
  
Sys-PolicyUninstall)
  # Do nothing
  ;;
  
*)
  GLB_nf_QuickExit "Policy aborted - Trigger '${sv_EventName}' is not supported by policy '${sv_PolicyName}'"
  ;;

esac
  
# ---

# Take a note that the Policy is complete
GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Policy done."

# Trigger an event
#/usr/local/LabWarden/lib/Trigger "${sv_EventHistory}:${sv_PolicyName}" "$(whoami)" "${sv_OptionalParam}"

# Remove temporary files
rm -fPR "${GLB_sv_ThisScriptTempDirPath}"

# ---
