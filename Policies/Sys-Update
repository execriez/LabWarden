#!/bin/bash
#
# Short:    Sys Policy script - Runs a custom update script
# Author:   Mark J Swift
# Version:  2.0.7
# Modified: 27-May-2017
#
# Triggered by the following events:
#   Sys-ManualUpdate    (as root)
#   Sys-LoginWindowIdle (as root)
#
# Called as follows:    
#   Sys-Update <ConfigFilePath> <ConfigEntryName> <EventHistory> <LoggedInUser> <OptionalParam>

# ---

sv_CodeVersion="2.0.7"

if [ $# -eq 0 ]
then
  echo "${sv_CodeVersion}"
  exit 0
fi

# ---

# Get the config file path
sv_ConfigFilePath="${1}"
if test -z "${sv_ConfigFilePath}"
then
  # We need something to work with
  exit 0
fi

# Get config entry name. This is the entry in the config that holds the configurable parameters for this policy.
sv_ConfigEntryName="${2}"

# Get event History
sv_EventHistory="${3}"

# Calculate the event that triggered this policy.
# This might be one of the following system events:
#   Sys-Boot, Sys-LoginWindow, Sys-NetworkUp, Sys-NetworkDown, Sys-Login, Sys-Logout, Sys-LoginWindowIdle, Sys-LoginWindowRestartOrShutdown, Sys-Poll
# ...or one of the following User events:
#   Usr-Login, Usr-AtDesktop, App-WillLaunch, App-DidLaunch, App-DidTerminate, Usr-Poll, Usr-Logout
sv_EventName="$(echo ${sv_EventHistory} | tr ":" "\n" | tail -n 1)"
if test -z "${sv_EventName}"
then
  # We need something to work with
  exit 0
fi

# Get the name of the logged in user, a null string signifies no-one is logged in
GLB_sv_LoggedInUserName="${4}"

# Get optional parameter
# This is a general variable that is currently used to pass the following info:
#   Application info during a AppWillLaunch, AppDidLaunch or AppDidTerminate event.
#   User info during a Sys-ConsoleUserLoggedIn, Sys-ConsoleUserLoggedOut, Sys-ConsoleUserSwitch, Sys-Login or Sys-Logout event.
sv_OptionalParam="${5}"

# Get info from optional parameter
case ${sv_EventName} in

Sys-ConsoleUserLoggedIn|Sys-ConsoleUserLoggedOut|Sys-ConsoleUserSwitch|Sys-Login|Sys-Logout)
  GLB_sv_LoggedInUserName="${sv_OptionalParam}"
  ;;
  
esac

# ---

# Load the library, only if it is not already loaded
if test -z "${GLB_sv_ProjectSignature}"
then
  . /usr/local/LabWarden/inc/Common.sh
fi

# By the time we get here, quite a few global variables have been set up.
# Look at 'CommonLib' for a complete list.

# ---

# Get policy name (Name of this script)
sv_PolicyName="${GLB_sv_ThisScriptName}"

# ---

# Calculate the pref file paths

# Local prefs are referenced by Policy UUID and are local to the running user. These are deleted when the policy is updated or uninstalled.
sv_ThisUserLocalPrefFilePath="${GLB_sv_ThisUserPrefDirPath}/${sv_ConfigEntryName}.plist"

# Global prefs are referenced by Policy Name and are read/write root but read-only for normal users. These survive policy updates and uninstalls.
sv_ThisPolicyGlobalPrefFilePath="${GLB_sv_ProjectConfigDirPath}/Config/Global/${sv_PolicyName}.plist"

# ---

# Usr-PolicyInstall & Usr-PolicyUninstall events (which are called as a normal user) are ignored by system policies

if [ "${sv_EventName}" = "Usr-PolicyInstall" ] || [ "${sv_EventName}" = "Usr-PolicyUninstall" ]
then
  GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Event '${sv_EventHistory}' ignored by policy '${sv_PolicyName}'"
  exit 0
fi

# ---

# check config "ActiveForDomain" setting to see if we are active or not. Can pass an optional subkey.
Sf_OptionIsActiveForThisDomain() # [subkey]
{
  local bv_IsActive
  local iv_IsActiveForDomainCount
  local sv_IsActiveForDomain
  
  sv_SubKey="${1}"
  if test -n "${sv_SubKey}" 
  then
    # add a single colon to the subkey
    sv_SubKey=$(echo "${sv_SubKey}:" | sed "s|[:]*$|:|")
  fi
  
  # Note, config "ActiveForDomain" value can be null, ALL, NONE, ADDOMAIN or your.company.domain

  bv_IsActive="false"
  iv_IsActiveForDomainCount="$(GLB_if_GetPlistArraySize "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:${sv_SubKey}ActiveForDomain")"
  for (( iv_IsActiveForDomainIndex=0; iv_IsActiveForDomainIndex<${iv_IsActiveForDomainCount}; iv_IsActiveForDomainIndex++ ))
  do
    sv_IsActiveForDomain=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:${sv_SubKey}ActiveForDomain:${iv_IsActiveForDomainIndex}")
    if test -n "${sv_IsActiveForDomain}"
    then
      case ${sv_IsActiveForDomain} in
      ALL)
        bv_IsActive="true"
        break 2
        ;;
        
      NONE)
        break 2
        ;;
        
      ADDOMAIN)
        sv_IsActiveForDomain="${GLB_sv_ADDomainNameDNS}"
        ;;
          
      esac
    fi
    
    if [ "${sv_IsActiveForDomain}" = "${GLB_sv_NetworkServiceDHCPOption15}" ]
    then
      bv_IsActive="true"
      break
    fi
  done
  
  echo "${bv_IsActive}"
}

Nf_DoUpdate()
{
  local bv_UpdateScriptActive
  local iv_UpdateExeArgCount
  local sv_UpdateExeURI
  local sv_UpdateExeFilePath
  local iv_UpdateExeArgIndex
  
  # Note, only active when on the specified domain(s) - can be null, ALL, NONE, ADDOMAIN or your.company.domain
  bv_UpdateScriptActive=$(Sf_OptionIsActiveForThisDomain "UpdateScript")
    
  if [ "${bv_UpdateScriptActive}" = "false" ]
  then
    GLB_nf_logmessage ${GLB_iv_MsgLevelWarn} "Update skipped - not on a known network."
      
  else
    iv_UpdateExeArgCount="$(GLB_if_GetPlistArraySize "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:UpdateScript:Exe")"
    if [ ${iv_UpdateExeArgCount} -eq 0 ]
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelWarn} "Update skipped - there are no defined update arguments."

    else
      sv_UpdateExeURI="$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:UpdateScript:Exe:0")"
      if test -n "${sv_UpdateExeURI}"
      then
        sv_UpdateExeFilePath=$(GLB_sf_ResolveFilename "${sv_UpdateExeURI}")
        if ! test -e "${sv_UpdateExeFilePath}"
        then
          # Its possible that we are assuming the lib directory
          sv_UpdateExeFilePath="/usr/local/LabWarden/lib/${sv_UpdateExeURI}"
        fi

        if ! test -e "${sv_UpdateExeFilePath}"
        then
          GLB_nf_logmessage ${GLB_iv_MsgLevelWarn} "Update skipped - update script does not exist (${sv_UpdateExeFilePath})"

        else
          if ! test -x "${sv_UpdateExeFilePath}"
          then
            chown root:wheel "${sv_UpdateExeFilePath}"
            chmod u+x "${sv_UpdateExeFilePath}"
          fi
          for (( iv_UpdateExeArgIndex=1; iv_UpdateExeArgIndex<${iv_UpdateExeArgCount}; iv_UpdateExeArgIndex++ ))
          do
            sv_UpdateExeFilePath="${sv_UpdateExeFilePath} '""$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:UpdateScript:Exe:${iv_UpdateExeArgIndex}")""'"
          done

          # Do a software update
          GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Running update (${sv_UpdateExeFilePath})"
          eval "${sv_UpdateExeFilePath}"
       fi
      fi
    fi
      
    # Do a full group policy update
    GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Updating group policies (via gpupdate)."
    /usr/local/LabWarden/util/gpupdate "-force"

    GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Ideally we should restart now"
    
  fi
  
}

# ---

# Execute the Policy

# Take a note of the Policy call
GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Policy '${sv_PolicyName}' ${sv_OptionalParam} triggered by event '${sv_EventHistory}' as user '${GLB_sv_ThisUserName}'"

# ---

# Exit if we are not root
if [ "${GLB_sv_ThisUserName}" != "root" ]
then
  GLB_nf_QuickExit "Policy aborted - User '${GLB_sv_ThisUserName}' is not supported by policy '${sv_PolicyName}'"
fi

# ---

case ${sv_EventName} in
    
Sys-ManualUpdate)
  # Manual update requested via /usr/local/LabWarden/util/Update
  GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Running a manual Update."
  
  # Perform a workstation update (software and group policies)
  Nf_DoUpdate
  ;;
  
Sys-LoginWindowIdle)
  iv_IdleSecs=$(GLB_if_SystemIdleSecs)
  GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Workstation Idle for ${iv_IdleSecs} secs"

  iv_LoginWindowIdleShutdownSecs=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:LoginWindowIdleShutdownSecs")
  if test -z "${iv_LoginWindowIdleShutdownSecs}"
  then
    iv_LoginWindowIdleShutdownSecs=0
  fi

  iv_NextUpdateEpoch=$(GLB_sf_GetPlistProperty "${sv_ThisPolicyGlobalPrefFilePath}" ":${sv_PolicyName}:GlobalPrefs:NextUpdateEpoch")
  if test -z "${iv_NextUpdateEpoch}"
  then
    iv_NextUpdateEpoch=0
  fi

  if [ ${GLB_iv_ThisScriptStartEpoch} -lt ${iv_NextUpdateEpoch} ]
  then
    GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Next update time not yet reached $(date -r ${iv_NextUpdateEpoch} "+%Y%m%d-%H:%M.%S")"

  else
    iv_CurrOutOfHoursStartTime=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:OutOfHoursStartTime" | grep -E "^[0-9]{1,2}:[0-9]{2}$")
    if test -n "${iv_CurrOutOfHoursStartTime}"
    then
      # Get update start time before now
      iv_CurrOutOfHoursStartHour=$(echo "${iv_CurrOutOfHoursStartTime}" | cut -d":" -f1)
      iv_CurrOutOfHoursStartMinute=$(echo "${iv_CurrOutOfHoursStartTime}" | cut -d":" -f2)
      iv_CurrOutOfHoursStartEpoch=$(date -r ${GLB_iv_ThisScriptStartEpoch} -v${iv_CurrOutOfHoursStartHour}H -v${iv_CurrOutOfHoursStartMinute}M -v0S "+%s")

      if [ ${GLB_iv_ThisScriptStartEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
      then
        iv_CurrOutOfHoursStartEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v-1d "+%s")
      fi

      iv_CurrOutOfHoursEndTime=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:OutOfHoursEndTime" | grep -E "^[0-9]{1,2}:[0-9]{2}$")
      if test -n "${iv_CurrOutOfHoursEndTime}"
      then
        iv_CurrOutOfHoursEndHour=$(echo "${iv_CurrOutOfHoursEndTime}" | cut -d":" -f1)
        iv_CurrOutOfHoursEndMinute=$(echo "${iv_CurrOutOfHoursEndTime}" | cut -d":" -f2)
        iv_CurrOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v${iv_CurrOutOfHoursEndHour}H -v${iv_CurrOutOfHoursEndMinute}M -v0S "+%s")

        if [ ${iv_CurrOutOfHoursEndEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
        then
          iv_CurrOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursEndEpoch} -v+1d "+%s")
        fi
      fi
    fi

    # Adjust end to allow at least one Sys-LoginWindowPoll to happen - if an update is scheduled at the end of the out-of-hours period
    iv_CurrOutOfHoursEndEpoch=$((${iv_CurrOutOfHoursEndEpoch}-${GLB_iv_SysLoginWindowPollTriggerSecs}*2))
    if [ ${iv_CurrOutOfHoursEndEpoch} -lt ${iv_CurrOutOfHoursStartEpoch} ]
    then
      # The period is clearly not long enough
      iv_CurrOutOfHoursEndEpoch=""
    fi

    bv_DoUpdate="false"
    
    if test -z "${iv_CurrOutOfHoursEndEpoch}"
    then
      GLB_nf_logmessage ${GLB_iv_MsgLevelWarn} "Out of hours slot is undefined or invalid"
      if [ ${iv_LoginWindowIdleShutdownSecs} -gt 0 ]
      then
        if [ ${iv_IdleSecs} -gt ${iv_LoginWindowIdleShutdownSecs} ]
        then
          # Update if we are about to do an idle Shutdown
          GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Updating before an idle shutdown"
          bv_DoUpdate="true"
        fi
      fi
      
    else
      # -- work out a good random-ish time to power on for the next Update
      iv_NextOutOfHoursStartEpoch=$(date -r ${iv_CurrOutOfHoursStartEpoch} -v+1d "+%s")
      iv_NextOutOfHoursEndEpoch=$(date -r ${iv_CurrOutOfHoursEndEpoch} -v+1d "+%s")
      iv_NextOutOfHoursUpdateEpoch=$(jot -r 1 ${iv_NextOutOfHoursStartEpoch} ${iv_NextOutOfHoursEndEpoch})
      
      bv_OutOfHoursPowerOn=$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:OutOfHoursPowerOn")
      if [ "${bv_OutOfHoursPowerOn}" = "true" ]
      then
        GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Scheduled PowerOn $(date -r ${iv_NextOutOfHoursUpdateEpoch} "+%Y%m%d-%H:%M.%S")"
        GLB_nf_schedule4epoch "${GLB_sv_ThisScriptFileName}" "poweron" ${iv_NextOutOfHoursUpdateEpoch}
        
        if [ ${GLB_iv_ThisScriptStartEpoch} -lt ${iv_CurrOutOfHoursEndEpoch} ]
        then
          # Do an update
          GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Performing an out-of-hours update"
          bv_DoUpdate="true"
        fi
      
      else
        GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Updates aren't scheduled"
        if [ ${iv_LoginWindowIdleShutdownSecs} -gt 0 ]
        then
          if [ ${iv_IdleSecs} -gt ${iv_LoginWindowIdleShutdownSecs} ]
          then
            # Shutdown if the workstation has been idle
            GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Updating before an idle shutdown"
            bv_DoUpdate="true"
          fi
        fi
        
      fi
    fi
    
    if [ "${bv_DoUpdate}" != "true" ]
    then
      if [ ${iv_NextUpdateEpoch} = 0 ]
      then
        GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Updating for the first time"
        bv_DoUpdate="true"
      fi
    fi
    
    if [ "${bv_DoUpdate}" = "true" ]
    then
      Nf_DoUpdate
      
      # If no next update can be determined, assume it's OK sometime after 4:00am
      if test -z "${iv_NextOutOfHoursUpdateEpoch}"
      then
        iv_NextOutOfHoursUpdateEpoch=$(date -r ${GLB_iv_ThisScriptStartEpoch} -v4H -v0M -v0S "+%s")
        if [ ${iv_NextOutOfHoursUpdateEpoch} -lt ${GLB_iv_ThisScriptStartEpoch} ]
        then
          iv_NextOutOfHoursUpdateEpoch=$(date -r ${iv_NextOutOfHoursUpdateEpoch} -v+1d "+%s")
        fi
      fi
          
      GLB_nf_SetPlistProperty "${sv_ThisPolicyGlobalPrefFilePath}" ":${sv_PolicyName}:GlobalPrefs:NextUpdateEpoch" "${iv_NextOutOfHoursUpdateEpoch}"
      GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Next update will likely be $(date -r ${iv_NextOutOfHoursUpdateEpoch} "+%Y%m%d-%H:%M.%S")"

      GLB_nf_RestartNow "ATTENTION, Update complete - restarting"
    fi
    
  fi

  
  if [ ${iv_LoginWindowIdleShutdownSecs} -gt 0 ]
  then
    if [ ${iv_IdleSecs} -gt ${iv_LoginWindowIdleShutdownSecs} ]
    then
      # Shutdown if the workstation has been idle
      GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Updating group policies before an idle shutdown"
      /usr/local/LabWarden/util/gpupdate "-force"
    fi
    if [ ${iv_IdleSecs} -gt ${iv_LoginWindowIdleShutdownSecs} ]
    then
      # Shutdown if the workstation is still idle
      GLB_nf_ShutdownNow "ATTENTION, workstation has been idle too long - we should shutdown"
    fi
  fi
  ;;
  
Sys-PolicyInstall|Sys-PolicyUninstall)
  # Do nothing
  ;;
  
*)
  GLB_nf_QuickExit "Policy aborted - Trigger '${sv_EventName}' is not supported by policy '${sv_PolicyName}'"
  ;;

esac
  
# ---

# Take a note that the Policy is complete
GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Policy done."

# Trigger an event
GLB_nf_TriggerEvent "${sv_EventHistory}" "${sv_PolicyName}" "${sv_OptionalParam}"

# Remove temporary files
rm -fPR "${GLB_sv_ThisScriptTempDirPath}"

# ---
