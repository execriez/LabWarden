#!/bin/bash
#
# Short:    Usr Policy script - Creates symbolic links between a network users network home and local home
# Author:   Mark J Swift
# Version:  2.0.15
# Modified: 07-Sep-2017
#
# This policy creates symbolic links at a path within a network users home folder that 
# point to files/folders in an "alternative" home. 
#
# With "Force local home directory on startup disk" enabled, the "alternate" home is the network home. 
# For network homes, the alternate home is the local home.
#
# It is called as the user and triggered by the "Usr-AtDesktop" and "Usr-ConsoleUserLoggedIn" events.
#
# If the "MakePathRedirections" key in the config is set to "false", then this policy will actively attempt
# to remove any existing redirections from the user home. 
# This is useful if you have been using folder redirections, and then change your mind.
#
# If the "MakePathRedirections" key in the config is set to "true", then this policy will act differently,
# depending on whether or not "Force local home directory on startup disk" is enabled.
#
# If "Force local home directory on startup disk" is enabled in the "User experience" tab
# of "Directory Utility", then it is serviced by the "Usr-AtDesktop" event.
#
# In this situation the user home is local, so the policy will attempt to create symbolic links 
# at a path within the user local home that point files/folders in the users network home. 
# These paths are defined in the config by the "Path" array within the "HomeIsLocal" key.
#
# If "Force local home directory on startup disk" is disabled in the "User experience" tab
# of "Directory Utility", then it is serviced by the "Usr-ConsoleUserLoggedIn" event.
#
# In this situation the user home is on the network, so the policy will attempt to create symbolic links
# at a path within the user network home that point to files/folders in the users local home. 
# These paths are defined in the config by the "Path" array within the "HomeIsOnNetwork" key.
#
# The policy will never apply path redirections on a mobile user account as this would make no sense.
#
# Triggered by the following events:
#   Usr-ConsoleUserLoggedIn (as user)
#   Usr-AtDesktop           (as user)
#
# Called as follows:    
#   Usr-HomeMakePathRedirections <ConfigFilePath> <ConfigEntryName> <EventHistory> <LoggedInUser> <OptionalParam>

# ---

sv_CodeVersion="2.0.15"

if [ $# -eq 0 ]
then
  echo "${sv_CodeVersion}"
  exit 0
fi

# ---

# Get the config file path
sv_ConfigFilePath="${1}"
if test -z "${sv_ConfigFilePath}"
then
  # We need something to work with
  exit 0
fi

# Get config entry name. This is the entry in the config that holds the configurable parameters for this policy.
sv_ConfigEntryName="${2}"

# Get event History
sv_EventHistory="${3}"

# Calculate the event that triggered this policy.
sv_EventName="$(echo ${sv_EventHistory} | tr ":" "\n" | tail -n 1)"
if test -z "${sv_EventName}"
then
  # We need something to work with
  exit 0
fi

# Get the name of the logged in user, a null string signifies no-one is logged in
GLB_sv_LoggedInUserName="${4}"

# Get optional parameter
# This is a general variable that is currently used to pass the following info:
#   Application info during a AppWillLaunch, AppDidLaunch or AppDidTerminate event.
#   User info during a Sys-ConsoleUserLoggedIn, Sys-ConsoleUserLoggedOut, Sys-ConsoleUserSwitch, Sys-Login or Sys-Logout event.
sv_OptionalParam="${5}"

# ---

# Load the library, only if it is not already loaded
if test -z "${GLB_sv_ProjectSignature}"
then
  . /usr/local/LabWarden/inc/Common.sh
fi

# By the time we get here, quite a few global variables have been set up.
# Look at 'CommonLib' for a complete list.

# ---

# Get policy name (Name of this script)
sv_PolicyName="${GLB_sv_ThisScriptName}"

# ---

# Calculate the pref file paths

# Local prefs are referenced by Policy UUID and are local to the running user. These are deleted when the policy is updated or uninstalled.
sv_ThisUserLocalPrefFilePath="${GLB_sv_ThisUserPrefDirPath}/${sv_ConfigEntryName}.plist"

# Global prefs are referenced by Policy Name and are read/write root but read-only for normal users. These survive policy updates and uninstalls.
sv_ThisPolicyGlobalPrefFilePath="${GLB_sv_ProjectConfigDirPath}/Config/Global/${sv_PolicyName}.plist"

# ---

# Sys-PolicyInstall & Sys-PolicyUninstall events (which are called as the root user) are ignored by user policies

if [ "${sv_EventName}" = "Sys-PolicyInstall" ] || [ "${sv_EventName}" = "Sys-PolicyUninstall" ]
then
  GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "Event '${sv_EventHistory}' ignored by policy '${sv_PolicyName}'"
  exit 0
fi

# ---

nf_ReloadFinder() # Reload the Finder
{
  GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Reloading the Finder" 
  pkill -U ${GLB_sv_ThisUserName} Finder
}

nf_UndoPathRedir() # FileRedirectList TargetHomeDir - Undo any existing home folder redirections
{
  local sv_TargetHomeDirPath
  local sv_RedirectListFilePath
  local sv_ReqdLinkEntry
  local sv_ReqdLinkFilePath

  sv_RedirectListFilePath="${1}"
  sv_TargetHomeDirPath="${2}"
    
  if test -f "${sv_RedirectListFilePath}"
  then
    # We may have symbolic links that need to be removed

    while read sv_ReqdLinkEntry
    do
      # Sanitise the Entry
      sv_ReqdLinkEntry=$(echo "/${sv_ReqdLinkEntry}" | sed "s|/[/]*|/|g")
  
      sv_ReqdLinkFilePath=$(echo "${sv_ReqdLinkEntry}" | sed "s|/$||")
      if test -n "${sv_ReqdLinkFilePath}"
      then
        if test -L "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
        then
          # There is a symbolic link where our file/folder should be
        
          if [ "${sv_ReqdLinkEntry}" != "${sv_ReqdLinkFilePath}" ]
          then
            # If the link was on a directory, re-create directory
            /bin/rm -f "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
            mkdir -p "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          else
            /bin/rm -f "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          fi

        fi
      fi
      
    done < "${sv_RedirectListFilePath}"
  
  fi
}

nf_DoPathRedir() # FileRedirectList TargetHomeDir SourceHomeDir
{
  local sv_TargetHomeDirPath
  local sv_SourceHomeDirPath
  local sv_RedirectListFilePath
  local sv_BackupDirPath
  local sv_ReqdLinkEntry
  local sv_ReqdLinkFilePath
  local sv_EnclosingDirPath
  local bv_TargetIsLocal
  local iv_StartEpoch
  local bv_GotError

  sv_RedirectListFilePath="${1}"
  sv_TargetHomeDirPath="${2}"    # Where the link files will be created
  sv_SourceHomeDirPath="${3}"    # Where the files/folders are that the links will be pointing to to

  # Take a note when this function started
  iv_StartEpoch=$(date -u "+%s")
  
  if test -f "${sv_RedirectListFilePath}"
  then
  
    # Decide whether the target is on the local drive
    if test -n "$(stat -f "%Sd" "${sv_TargetHomeDirPath}" | grep "^disk")"
    then
      bv_TargetIsLocal="true"
    else
      bv_TargetIsLocal="false"
    fi

    # Backup location for existing files/folders that might be replaced by a link
    sv_BackupDirPath="${sv_TargetHomeDirPath}Backup/"$(date -r ${iv_StartEpoch} '+%Y-%m-%d_%H-%M-%S')

    # Read entries from file
    while read sv_ReqdLinkEntry
    do
      bv_GotError="false"

      # Sanitise the Entry
      sv_ReqdLinkEntry=$(echo "/${sv_ReqdLinkEntry}" | sed "s|/[/]*|/|g")
      
      sv_ReqdLinkFilePath=$(echo "${sv_ReqdLinkEntry}" | sed "s|/$||")
      if test -n "${sv_ReqdLinkFilePath}"
      then
      
        # Make sure there is a target enclosing folder to store the symbolic link
        sv_EnclosingDirPath="$(dirname "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}")"
        /bin/mkdir -p "${sv_EnclosingDirPath}"
      
        # Make sure we have a source folder or source file parent folder
        if [ "${sv_ReqdLinkEntry}" != "${sv_ReqdLinkFilePath}" ]
        then
          # We are linking to a directory - so make sure it exists
          /bin/mkdir -p "${sv_SourceHomeDirPath}${sv_ReqdLinkFilePath}"
          if [ $? -ne 0 ]
          then
            GLB_nf_logmessage ${GLB_iv_MsgLevelErr} "Error creating folder '${sv_SourceHomeDirPath}${sv_ReqdLinkFilePath}'"
            bv_GotError="true"
          fi
        else
          # We are linking to a file - so make sure the parent folder exists
          sv_EnclosingDirPath="$(dirname "${sv_SourceHomeDirPath}${sv_ReqdLinkFilePath}")"
          /bin/mkdir -p "${sv_EnclosingDirPath}"
          if [ $? -ne 0 ]
          then
            GLB_nf_logmessage ${GLB_iv_MsgLevelErr} "Error creating folder '${sv_EnclosingDirPath}'"
            bv_GotError="true"
          fi
        fi
      
        # If there are errors at source, delete any existing link at target
        if [ "${bv_GotError}" = "true" ]
        then
          if test -L "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          then
            rm -f "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          fi
        
        else
        
          if test -L "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          then
            # If the filepath references a link, get the originating filepath
            sv_ExistingLinkTargetPath="$(stat -f %Y "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}")"
            if [ "${sv_ExistingLinkTargetPath}" = "${sv_SourceHomeDirPath}${sv_ReqdLinkFilePath}" ]
            then
              GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "A valid link already exists for folder '${sv_ReqdLinkFilePath}'."
            else
              rm -f "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
            fi
          fi

          # Back up anything that exists at the target (where the link is going to be stored)
          if test -e "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          then
            # something exists at the target
            if ! test -L "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
            then
              # Its not an existing link
              if test -d "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
              then
                # If the existing folder at the target is local, remove any ACLs that might stop us doing our stuff
                if [ "${bv_TargetIsLocal}" = "true" ]
                then
                  /bin/chmod -RN "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
                fi
                # Check if existing folder is empty - and backup if necessary
                if test -z "$(ls -A1 "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}" | grep -Ev "^.DS_Store$|^.localized$")"
                then
                  GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Deleting empty folder '${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}'."
                  /bin/rm -fR "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
                else
                  GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Backing up existing folder '${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}'."
                  # Make sure there is a target enclosing folder to backup the folder
                  sv_EnclosingDirPath="$(dirname "${sv_BackupDirPath}${sv_ReqdLinkFilePath}")"
                  /bin/mkdir -p "${sv_EnclosingDirPath}"
                  # Move (back up) existing folder at target
                  /bin/mv -f "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}" "${sv_EnclosingDirPath}/"
                fi
              else
                GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Backing up existing file '${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}'."
                # If the existing file at the target is local, remove any ACLs that might stop us doing our stuff
                if [ "${bv_TargetIsLocal}" = "true" ]
                then
                  /bin/chmod -N "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
                fi
                # Make sure there is a target enclosing folder to backup the file
                sv_EnclosingDirPath="$(dirname "${sv_BackupDirPath}${sv_ReqdLinkFilePath}")"
                /bin/mkdir -p "${sv_EnclosingDirPath}"
                # Move (back up) existing file at target
                /bin/mv -f "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}" "${sv_EnclosingDirPath}/"
              fi
            fi
          fi
          
          # Only create the link if nothing exists at the target
          if ! test -e "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          then
            # Create link - source file/folder -to- target link
            GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Creating link for folder '${sv_ReqdLinkFilePath}'."
            /bin/ln -sf "${sv_SourceHomeDirPath}${sv_ReqdLinkFilePath}" "${sv_TargetHomeDirPath}${sv_ReqdLinkFilePath}"
          fi

        fi
      fi
    done < "${sv_RedirectListFilePath}"

  fi

}

nf_UnmakePathRedirections()
{
  if test -s "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
  then
    nf_UndoPathRedir "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt" "${GLB_sv_LoggedInUserHomeDirPath}"
  fi

  # Check if the Desktop was linked/unlinked
  if test -n "$(printf "$(cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt")" | grep -E "^/Desktop/$")"
  then
    # Kill the Finder (Refreshes Desktop)
    GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Folder redirections removed - Finder needs to be reloaded"
    nf_ReloadFinder
  fi

  rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"

}

nf_MakePathRedirections()
{
  local sv_DoRedir
  local sv_LoggedInUserHomeAltDirPath
  local sv_RedirPathConfigKey
  local sv_ReqdLinkEntry
  local sv_ReqdLinkFilePath
  local iv_ObjectCount
  local iv_LoopCount
  
  sv_DoRedir="$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:MakePathRedirections")"
  if [ "${sv_DoRedir}" = "false" ]
  then
    # Config tells us to unmake any existing folder redirections
    nf_UnmakePathRedirections
    
  else
    # Config tells us to make folder redirections
    if [ "${GLB_bv_LoggedInUserHomeIsLocal}" = "true" ]
    then
      # The user home is local, so the links should point to the network home
      sv_RedirPathConfigKey="HomeIsLocal"
    
      # Links should point to the network home
      sv_LoggedInUserHomeAltDirPath="${GLB_sv_LoggedInUserHomeNetworkDirPath}"
    
    else
      # The user home is on the network
      sv_RedirPathConfigKey="HomeIsOnNetwork"

      # Links should point to the local home
      sv_LoggedInUserHomeAltDirPath="${GLB_sv_LoggedInUserLocalHomeDirPath}"
 
    fi

    if [ -z "${sv_LoggedInUserHomeAltDirPath}" ]
    then
      # The alternate home dir is unavailable - so remove any existing redirections
      # Shouldn't ever get here, because this condition is dealt with before this function is called
      GLB_nf_logmessage ${GLB_iv_MsgLevelErr} "Error, alternate home dir is unavailable."
      nf_UnmakePathRedirections
      
    else
      GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "sv_LoggedInUserHomeAltDirPath ${sv_LoggedInUserHomeAltDirPath}"
      GLB_nf_logmessage ${GLB_iv_MsgLevelDebug} "GLB_sv_LoggedInUserHomeDirPath ${GLB_sv_LoggedInUserHomeDirPath}"
    
      # There shouldn't be any folder redirections on the alternate home
      # If there are, these may have been left when swapping between "Network Homes" and "Force local homes".
      if test -s "${sv_LoggedInUserHomeAltDirPath}/.FolderRedir.txt"
      then
        nf_UndoPathRedir "${sv_LoggedInUserHomeAltDirPath}/.FolderRedir.txt" "${sv_LoggedInUserHomeAltDirPath}"
      fi
      rm -f "${sv_LoggedInUserHomeAltDirPath}/.FolderRedir.txt"

      # Make sure the link list exists
      touch "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"

      # Check the existing link list
      rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Old.txt"
      touch "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Old.txt"
      while read sv_ReqdLinkEntry
      do
        # Sanitise the Entry
        sv_ReqdLinkEntry=$(echo "/${sv_ReqdLinkEntry}" | sed "s|/[/]*|/|g")
        sv_ReqdLinkFilePath=$(echo "${sv_ReqdLinkEntry}" | sed "s|/$||")
        if test -n "${sv_ReqdLinkFilePath}"
        then
          if test -L "${GLB_sv_LoggedInUserHomeDirPath}${sv_ReqdLinkFilePath}"
          then
            echo "${sv_ReqdLinkEntry}" >>"${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Old.txt"
          fi
        fi
      done < "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
            
      # Create the required link list
      rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
      touch "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
      iv_ObjectCount="$(GLB_if_GetPlistArraySize "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:${sv_RedirPathConfigKey}:Path")"
      for (( iv_LoopCount=0; iv_LoopCount<${iv_ObjectCount}; iv_LoopCount++ ))
      do
        sv_ReqdLinkEntry="$(GLB_sf_GetPlistProperty "${sv_ConfigFilePath}" ":${sv_ConfigEntryName}:Config:${sv_RedirPathConfigKey}:Path:${iv_LoopCount}")"
        sv_ReqdLinkEntry=$(echo "/${sv_ReqdLinkEntry}" | sed "s|/[/]*|/|g")
        sv_ReqdLinkFilePath=$(echo "${sv_ReqdLinkEntry}" | sed "s|/$||")
        if test -n "${sv_ReqdLinkFilePath}"
        then
          echo "${sv_ReqdLinkEntry}" >>"${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
        fi
      done
      
      # Find out which folders we need to check for links/unlinks
      echo "$(cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt" ; cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Old.txt" )" | sort -u > "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Check.txt"

      # Find out which folders we need to unlink (if we ever change the link list)
      echo "$(cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt" ; cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Check.txt" )" | sort | uniq -u > "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Unlink.txt"

      # Find out which folders we need to link
      echo "$(cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Old.txt" ; cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Check.txt" )" | sort | uniq -u > "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Link.txt"

      # Link files (did use .FolderRedir-Link.txt, but the alternate home folder might change - so we should remake all links)
      if test -s "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
      then
        GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Linking folders."
        nf_DoPathRedir  "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt" "${GLB_sv_LoggedInUserHomeDirPath}" "${sv_LoggedInUserHomeAltDirPath}"
      fi

      # Unlink files
      if test -s "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Unlink.txt"
      then
        GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Unlinking folders."
        nf_UndoPathRedir "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Unlink.txt" "${GLB_sv_LoggedInUserHomeDirPath}"
      fi

      # Check if the Desktop was linked/unlinked
      if test -n "$(printf "$(cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Unlink.txt";cat "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Link.txt")" | grep -E "^/Desktop/$")"
      then
        # Kill the Finder (Refreshes Desktop)
        GLB_nf_logmessage ${GLB_iv_MsgLevelNotice} "Folders redirected - Finder needs to be reloaded."
        nf_ReloadFinder
      fi

      # Delete temporary files
      rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Old.txt"
      rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Check.txt"
      rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Unlink.txt"
      rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir-Link.txt"

      # Delete the link file if it is empty
      if ! test -s "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
      then
        # Link list file is empty
        GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "There are no defined folder redirections."
        rm -f "${GLB_sv_LoggedInUserHomeDirPath}/.FolderRedir.txt"
        
      fi      
      
    fi     
  fi

}

# ---

# Execute the Policy

# Take a note of the Policy call
GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Policy '${sv_PolicyName}' ${sv_OptionalParam} triggered by event '${sv_EventHistory}' as user '${GLB_sv_ThisUserName}'"

# ---

# Exit if we are an unsupported user
case ${GLB_sv_ThisUserName} in
    
root|_mbsetupuser)
  GLB_nf_QuickExit "Policy aborted - User '${GLB_sv_ThisUserName}' is not supported by policy '${sv_PolicyName}'"
  ;;
  
esac

# Exit if no-one is logged in
if test -z "${GLB_sv_LoggedInUserName}"
then
  GLB_nf_QuickExit "Policy aborted - No-one is logged in."
fi
   
# ---

# Exit if the user home folder doesn't exist
if [ ! -e "${GLB_sv_LoggedInUserHomeDirPath}" ]
then
  GLB_nf_QuickExit "Policy aborted - home folder doesn't exist."
fi

# Exit if user is a local account
if [ "${GLB_bv_LoggedInUserIsLocal}" = "true" ]
then
  GLB_nf_QuickExit "Policy aborted - User account is local."
fi

# Exit if user is a mobile account
if [ "${GLB_bv_LoggedInUserIsMobile}" = "true" ]
then
  GLB_nf_QuickExit "Policy aborted - User account is mobile."
fi

# ---

case ${sv_EventName} in
    
Usr-AtDesktop|Usr-PolicyInstall)
  # Folder redirections on "forced local" homes are done when the user gets to a desktop
  if [ "${GLB_bv_LoggedInUserHomeIsLocal}" = "false" ]
  then
    # The user home is on the network
    GLB_nf_QuickExit "Policy aborted - conditions met, but policy doesn't run during a ${sv_EventName} event."
       
  else
    # The user home is "forced local"

    if [ -z "${GLB_sv_LoggedInUserHomeNetworkDirPath}" ]
    then
      # "Force local home directory on startup disk" is enabled, but there is no network home mounted
        
      nf_UnmakePathRedirections
      GLB_nf_ShowNotification ${GLB_iv_MsgLevelWarn} "Network share is not available at present. Try Restarting."

    else
      nf_MakePathRedirections

    fi
        
  fi
  ;;
      
Usr-ConsoleUserLoggedIn)
  # Folder redirections on network homes are done as the user is logging in
  if [ "${GLB_bv_LoggedInUserHomeIsLocal}" = "true" ]
  then
    # The user home is "forced local"
    GLB_nf_QuickExit "NOTE, policy aborted: conditions met, but policy doesn't run during a ${sv_EventName} event."
       
  else
    # The user home is on the network

    if [ ! -e "${GLB_sv_LoggedInUserLocalHomeDirPath}" ]
    then
      # User home is on the network, but there is no local home
        
      nf_UnmakePathRedirections
      GLB_nf_QuickExit "Policy aborted - Local home is unavailable - that's odd."
    
    else
      nf_MakePathRedirections

    fi
        
  fi
  ;;

Usr-PolicyUninstall)
  nf_UnmakePathRedirections
  ;;
  
*)
GLB_nf_QuickExit "Policy aborted - Trigger '${sv_EventName}' is not supported by policy '${sv_PolicyName}'"
;;

esac

# ---

# Take a note that the Policy is complete
GLB_nf_logmessage ${GLB_iv_MsgLevelInfo} "Policy done."

# Trigger an event
#GLB_nf_TriggerEvent "${sv_EventHistory}" "${sv_PolicyName}" "${sv_OptionalParam}"

# Remove temporary files
rm -fPR "${GLB_sv_ThisScriptTempDirPath}"

# ---
